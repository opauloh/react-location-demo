var _excluded = ["children", "location"],
    _excluded2 = ["to", "search", "hash", "children", "target", "style", "replace", "onClick", "onMouseEnter", "className", "getActiveProps", "activeOptions", "preload", "disabled", "_ref"],
    _excluded3 = ["style", "className"],
    _excluded4 = ["pending"],
    _excluded5 = ["children"];

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

import * as React from 'react';
import { createHashHistory, createBrowserHistory, createMemoryHistory } from 'history';
export { createHashHistory, createBrowserHistory, createMemoryHistory }; // Types

// Source
var LocationContext = /*#__PURE__*/React.createContext(null);
var MatchesContext = /*#__PURE__*/React.createContext(null);
var routerContext = /*#__PURE__*/React.createContext(null); // Detect if we're in the DOM

var isDOM = Boolean(typeof window !== 'undefined' && window.document && window.document.createElement);
var useLayoutEffect = isDOM ? React.useLayoutEffect : React.useEffect; // This is the default history object if none is defined

var createDefaultHistory = function createDefaultHistory() {
  return isDOM ? createBrowserHistory() : createMemoryHistory();
};

var Subscribable = /*#__PURE__*/function () {
  function Subscribable() {
    this.listeners = [];
  }

  var _proto = Subscribable.prototype;

  _proto.subscribe = function subscribe(listener) {
    var _this = this;

    this.listeners.push(listener);
    return function () {
      _this.listeners = _this.listeners.filter(function (x) {
        return x !== listener;
      });
    };
  };

  _proto.notify = function notify(payload) {
    this.listeners.forEach(function (listener) {
      return listener(payload);
    });
  };

  return Subscribable;
}();

export var ReactLocation = /*#__PURE__*/function (_Subscribable) {
  _inheritsLoose(ReactLocation, _Subscribable);

  //
  function ReactLocation(options) {
    var _options$stringifySea, _options$parseSearch;

    var _this2;

    _this2 = _Subscribable.call(this) || this;
    _this2.isTransitioning = false;
    _this2.history = (options == null ? void 0 : options.history) || createDefaultHistory();
    _this2.stringifySearch = (_options$stringifySea = options == null ? void 0 : options.stringifySearch) != null ? _options$stringifySea : defaultStringifySearch;
    _this2.parseSearch = (_options$parseSearch = options == null ? void 0 : options.parseSearch) != null ? _options$parseSearch : defaultParseSearch;
    _this2.current = _this2.parseLocation(_this2.history.location);
    _this2.destroy = _this2.history.listen(function (event) {
      _this2.current = _this2.parseLocation(event.location, _this2.current);

      _this2.notify();
    });
    return _this2;
  }

  var _proto2 = ReactLocation.prototype;

  _proto2.buildNext = function buildNext(basepath, dest) {
    var _dest$to, _ref2, _dest$__searchFilters;

    if (basepath === void 0) {
      basepath = '/';
    }

    if (dest === void 0) {
      dest = {};
    }

    var from = _extends({}, this.current, dest.from);

    var pathname = resolvePath(basepath, from.pathname, "" + ((_dest$to = dest.to) != null ? _dest$to : '.'));
    var updatedSearch = (_ref2 = dest.search === true ? from.search : functionalUpdate(dest.search, from.search)) != null ? _ref2 : {};
    var filteredSearch = (_dest$__searchFilters = dest.__searchFilters) != null && _dest$__searchFilters.length ? dest.__searchFilters.reduce(function (prev, next) {
      return next(prev, updatedSearch);
    }, from.search) : updatedSearch;
    var search = replaceEqualDeep(from.search, filteredSearch);
    var searchStr = this.stringifySearch(search);
    var hash = functionalUpdate(dest.hash, from.hash);
    hash = hash ? "#" + hash : '';
    return {
      pathname: pathname,
      search: search,
      searchStr: searchStr,
      hash: hash,
      href: "" + pathname + searchStr + hash,
      key: dest.key
    };
  };

  _proto2.navigate = function navigate(next, replace) {
    var _this3 = this;

    this.current = next;
    if (this.navigateTimeout) clearTimeout(this.navigateTimeout);
    var nextAction = 'replace';

    if (!this.nextAction) {
      nextAction = replace ? 'replace' : 'push';
    }

    if (!replace) {
      nextAction = 'push';
    }

    this.nextAction = nextAction;
    this.navigateTimeout = setTimeout(function () {
      var nextAction = _this3.nextAction;
      delete _this3.nextAction;

      var isSameUrl = _this3.parseLocation(_this3.history.location).href === _this3.current.href;

      if (isSameUrl && !_this3.current.key) {
        nextAction = 'replace';
      }

      if (nextAction === 'replace') {
        return _this3.history.replace({
          pathname: _this3.current.pathname,
          hash: _this3.current.hash,
          search: _this3.current.searchStr
        });
      }

      return _this3.history.push({
        pathname: _this3.current.pathname,
        hash: _this3.current.hash,
        search: _this3.current.searchStr
      });
    }, 16);
  };

  _proto2.parseLocation = function parseLocation(location, previousLocation) {
    var _location$hash$split$;

    var parsedSearch = this.parseSearch(location.search);
    return {
      pathname: location.pathname,
      searchStr: location.search,
      search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
      hash: (_location$hash$split$ = location.hash.split('#').reverse()[0]) != null ? _location$hash$split$ : '',
      href: "" + location.pathname + location.search + location.hash,
      key: location.key
    };
  };

  return ReactLocation;
}(Subscribable);
export function MatchesProvider(props) {
  return /*#__PURE__*/React.createElement(MatchesContext.Provider, props);
}
export function Router(_ref3) {
  var children = _ref3.children,
      location = _ref3.location,
      rest = _objectWithoutPropertiesLoose(_ref3, _excluded);

  var routerRef = React.useRef(null);

  if (!routerRef.current) {
    routerRef.current = new RouterInstance(_extends({}, rest, {
      location: location
    }));
  }

  var router = routerRef.current;

  var _React$useReducer = React.useReducer(function () {
    return {};
  }, {}),
      nonce = _React$useReducer[0],
      rerender = _React$useReducer[1];

  useLayoutEffect(function () {
    return router.subscribe(rerender);
  }, []);
  useLayoutEffect(function () {
    return router.updateLocation(location.current).unsubscribe;
  }, [location.current.key]);
  var routerValue = React.useMemo(function () {
    return {
      router: router
    };
  }, [nonce]);
  return /*#__PURE__*/React.createElement(LocationContext.Provider, {
    value: location
  }, /*#__PURE__*/React.createElement(routerContext.Provider, {
    value: routerValue
  }, /*#__PURE__*/React.createElement(MatchesProvider, {
    value: [router.rootMatch].concat(router.state.matches)
  }, children)));
}
export var RouterInstance = /*#__PURE__*/function (_Subscribable2) {
  _inheritsLoose(RouterInstance, _Subscribable2);

  function RouterInstance(opts) {
    var _opts$basepath, _opts$initialMatches;

    var _this4;

    _this4 = _Subscribable2.call(this) || this;

    _this4.setState = function (updater) {
      var newState = updater({
        state: _this4.state,
        pending: _this4.pending
      });
      _this4.state = newState.state;
      _this4.pending = newState.pending;

      _this4.cleanMatchCache();

      _this4.notify();
    };

    _this4.matchCache = {};

    _this4.getMatchLoader = function (next) {
      return new MatchLoader(_assertThisInitialized(_this4), next);
    };

    _this4.cleanMatchCache = function () {
      var _assertThisInitialize, _assertThisInitialize2, _assertThisInitialize3, _assertThisInitialize4, _assertThisInitialize5;

      var activeMatchIds = [].concat((_assertThisInitialize = (_assertThisInitialize2 = _assertThisInitialized(_this4)) == null ? void 0 : _assertThisInitialize2.state.matches) != null ? _assertThisInitialize : [], (_assertThisInitialize3 = (_assertThisInitialize4 = _assertThisInitialized(_this4)) == null ? void 0 : (_assertThisInitialize5 = _assertThisInitialize4.pending) == null ? void 0 : _assertThisInitialize5.matches) != null ? _assertThisInitialize3 : []).map(function (d) {
        return d.id;
      });
      Object.values(_this4.matchCache).forEach(function (match) {
        var _match$updatedAt;

        if (!match.updatedAt) {
          return;
        }

        if (activeMatchIds.includes(match.id)) {
          return;
        }

        var age = Date.now() - ((_match$updatedAt = match.updatedAt) != null ? _match$updatedAt : 0);

        if (!match.maxAge || age > match.maxAge) {
          delete _this4.matchCache[match.id];
        }
      });
    };

    _this4.updateLocation = function (next) {
      var unsubscribe;
      var promise = new Promise(function (resolve) {
        var _this4$state$matches;

        var matchLoader = _this4.getMatchLoader(next);

        (_this4$state$matches = _this4.state.matches) == null ? void 0 : _this4$state$matches.forEach(function (match) {
          match.used = true;
        });

        _this4.setState(function (old) {
          return _extends({}, old, {
            pending: {
              status: 'pending',
              location: matchLoader.location,
              matches: matchLoader.matches
            }
          });
        });

        unsubscribe = matchLoader.subscribe(function () {
          var currentMatches = _this4.state.matches;
          currentMatches.filter(function (d) {
            return !matchLoader.matches.find(function (dd) {
              return dd.id === d.id;
            });
          }).forEach(function (d) {
            d.onExit == null ? void 0 : d.onExit(d);
          });
          currentMatches.filter(function (d) {
            return matchLoader.matches.find(function (dd) {
              return dd.id === d.id;
            });
          }).forEach(function (d) {
            d.route.onTransition == null ? void 0 : d.route.onTransition(d);
          });
          matchLoader.matches.filter(function (d) {
            return !currentMatches.find(function (dd) {
              return dd.id === d.id;
            });
          }).forEach(function (d) {
            d.onExit = d.route.onMatch == null ? void 0 : d.route.onMatch(d);
          });

          _this4.setState(function (old) {
            return _extends({}, old, {
              state: {
                status: 'ready',
                location: matchLoader.location,
                matches: matchLoader.matches
              },
              pending: undefined
            });
          });

          resolve();
        });
        matchLoader.loadData();
        matchLoader.startPending();
      });
      return {
        promise: promise,
        unsubscribe: unsubscribe
      };
    };

    Object.assign(_assertThisInitialized(_this4), opts);
    _this4.basepath = cleanPath("/" + ((_opts$basepath = opts.basepath) != null ? _opts$basepath : ''));
    _this4.rootMatch = {
      id: 'root',
      params: {},
      search: {},
      routeIndex: 0,
      pathname: _this4.basepath,
      route: null,
      data: {},
      isLoading: false,
      status: 'resolved'
    };
    _this4.state = {
      status: 'ready',
      location: opts.location.current,
      matches: (_opts$initialMatches = opts.initialMatches) != null ? _opts$initialMatches : []
    };
    opts.location.subscribe(function () {
      return _this4.notify();
    });
    return _this4;
  }

  return RouterInstance;
}(Subscribable);
export function useLocation() {
  var getIsMounted = useGetIsMounted();

  var _React$useReducer2 = React.useReducer(function (d) {
    return d + 1;
  }, 0),
      rerender = _React$useReducer2[1];

  var instance = React.useContext(LocationContext);
  process.env.NODE_ENV !== "production" ? warning(!!instance, 'useLocation must be used within a <ReactLocation />') : void 0;
  useLayoutEffect(function () {
    return instance.subscribe(function () {
      // Rerender all subscribers in a microtask
      Promise.resolve().then(function () {
        setTimeout(function renderAllLocationSubscribers() {
          if (getIsMounted()) {
            rerender();
          }
        }, 0);
      });
    });
  }, [instance]);
  return instance;
}
export var RouteMatch = function RouteMatch(unloadedMatch) {
  var _this5 = this;

  this.status = 'pending';
  this.data = {};
  this.isLoading = false;

  this.notify = function (isSoft) {
    var _this5$matchLoader;

    (_this5$matchLoader = _this5.matchLoader) == null ? void 0 : _this5$matchLoader.notify(isSoft);
  };

  this.assignMatchLoader = function (matchLoader) {
    _this5.matchLoader = matchLoader;
  };

  this.startPending = function () {
    if (_this5.pendingTimeout) {
      clearTimeout(_this5.pendingTimeout);
    }

    if (_this5.route.pendingMs) {
      _this5.pendingTimeout = setTimeout(function () {
        _this5.notify == null ? void 0 : _this5.notify();

        if (typeof _this5.route.pendingMinMs !== 'undefined') {
          _this5.pendingMinPromise = new Promise(function (r) {
            return setTimeout(r, _this5.route.pendingMinMs);
          });
        }
      }, _this5.route.pendingMs);
    }
  };

  this.load = function (opts) {
    var _ref4, _opts$maxAge;

    _this5.maxAge = (_ref4 = (_opts$maxAge = opts.maxAge) != null ? _opts$maxAge : _this5.route.loaderMaxAge) != null ? _ref4 : opts.router.defaultLoaderMaxAge;

    if (_this5.loaderPromise) {
      return;
    }

    var importer = _this5.route.import; // First, run any importers

    _this5.loaderPromise = (!importer ? Promise.resolve() : importer({
      params: _this5.params,
      search: _this5.search
    }).then(function (imported) {
      _this5.route = _extends({}, _this5.route, imported);
    }) // then run all element and data loaders in parallel
    ).then(function () {
      var elementPromises = []; // For each element type, potentially load it asynchronously

      var elementTypes = ['element', 'errorElement', 'pendingElement'];
      elementTypes.forEach(function (type) {
        var routeElement = _this5.route[type];

        if (_this5[type]) {
          return;
        }

        if (typeof routeElement === 'function') {
          elementPromises.push(routeElement(_this5).then(function (res) {
            _this5[type] = res;
          }));
        } else {
          _this5[type] = _this5.route[type];
        }
      });
      var loader = _this5.route.loader;
      var dataPromise = !loader ? Promise.resolve().then(function () {
        _this5.status = 'resolved';
      }) : new Promise(function (resolveLoader, rejectLoader) {
        return new Promise(function ($return, $error) {
          var pendingTimeout, resolve, reject, finish;

          resolve = function resolve(data) {
            _this5.status = 'resolved';
            _this5.data = data;
            _this5.error = undefined;
          };

          reject = function reject(err) {
            console.error(err);
            _this5.status = 'rejected';
            _this5.error = err;
            rejectLoader(err);
          };

          finish = function finish() {
            _this5.isLoading = false;
            _this5.startPending = undefined;
            clearTimeout(pendingTimeout);
            resolveLoader(_this5.data);
          };

          var $Try_1_Post = function () {
            try {
              return $return();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          };

          var $Try_1_Catch = function (err) {
            try {
              reject(err);
              finish();
              return $Try_1_Post();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          };

          try {
            _this5.isLoading = true;
            return Promise.resolve(loader(_this5, {
              parentMatch: opts.parentMatch,
              dispatch: function dispatch(event) {
                return new Promise(function ($return, $error) {
                  if (event.type === 'resolve') {
                    resolve(event.data);
                  } else if (event.type === 'reject') {
                    reject(event.error);
                  } else if (event.type === 'loading') {
                    _this5.isLoading = true;
                  } else if (event.type === 'maxAge') {
                    _this5.maxAge = event.maxAge;
                  }

                  _this5.updatedAt = Date.now();
                  _this5.notify == null ? void 0 : _this5.notify(true);
                  return $return();
                });
              }
            })).then(function ($await_6) {
              try {
                resolve($await_6);
                return Promise.resolve(_this5.pendingMinPromise).then(function ($await_7) {
                  try {
                    finish();
                    return $Try_1_Post();
                  } catch ($boundEx) {
                    return $Try_1_Catch($boundEx);
                  }
                }, $Try_1_Catch);
              } catch ($boundEx) {
                return $Try_1_Catch($boundEx);
              }
            }, $Try_1_Catch);
          } catch (err) {
            $Try_1_Catch(err)
          }
        });
      });
      return Promise.all([].concat(elementPromises, [dataPromise])).then(function () {
        _this5.updatedAt = Date.now();
      });
    }).then(function () {
      return _this5.data;
    });
  };

  Object.assign(this, unloadedMatch);
};

var MatchLoader = /*#__PURE__*/function (_Subscribable3) {
  _inheritsLoose(MatchLoader, _Subscribable3);

  function MatchLoader(router, nextLocation) {
    var _this6;

    _this6 = _Subscribable3.call(this) || this;
    _this6.status = 'pending';

    _this6.preNotify = function (isSoft) {
      var _this6$matches;

      if (_this6.status === 'pending' && isSoft) {
        return;
      }

      _this6.status = 'resolved';
      (_this6$matches = _this6.matches) == null ? void 0 : _this6$matches.forEach(function (match, index) {
        var _this6$matches2, _parentMatch$data;

        var parentMatch = (_this6$matches2 = _this6.matches) == null ? void 0 : _this6$matches2[index - 1];
        match.data = _extends({}, (_parentMatch$data = parentMatch == null ? void 0 : parentMatch.data) != null ? _parentMatch$data : {}, match.data);
      });

      _this6.notify(false);
    };

    _this6.loadMatches = function () {
      var unloadedMatches = matchRoutes(_this6.router, _this6.location);
      _this6.matches = unloadedMatches == null ? void 0 : unloadedMatches.map(function (unloadedMatch) {
        if (!_this6.router.matchCache[unloadedMatch.id]) {
          _this6.router.matchCache[unloadedMatch.id] = new RouteMatch(unloadedMatch);
        }

        return _this6.router.matchCache[unloadedMatch.id];
      });
    };

    _this6.loadData = function (_temp) {
      return new Promise(function ($return, $error) {
        var _this6$matches3, _ref5, maxAge;

        _ref5 = _temp === void 0 ? {} : _temp, maxAge = _ref5.maxAge;

        _this6.loadMatches();

        _this6.router.cleanMatchCache();

        if (!((_this6$matches3 = _this6.matches) != null && _this6$matches3.length)) {
          _this6.preNotify();

          return $return();
        }

        _this6.firstRenderPromises = [];

        _this6.matches.forEach(function (match, index) {
          var _this6$matches4, _this6$firstRenderPro;

          var parentMatch = (_this6$matches4 = _this6.matches) == null ? void 0 : _this6$matches4[index - 1];
          match.assignMatchLoader == null ? void 0 : match.assignMatchLoader(_assertThisInitialized(_this6));
          match.load == null ? void 0 : match.load({
            maxAge: maxAge,
            parentMatch: parentMatch,
            router: _this6.router
          });
          (_this6$firstRenderPro = _this6.firstRenderPromises) == null ? void 0 : _this6$firstRenderPro.push(match.loaderPromise);
        });

        return Promise.resolve(Promise.all(_this6.firstRenderPromises).then(function () {
          _this6.preNotify();

          return _this6.matches;
        })).then($return, $error);
      });
    };

    _this6.load = function (_temp2) {
      return new Promise(function ($return, $error) {
        var _ref6, maxAge;

        _ref6 = _temp2 === void 0 ? {} : _temp2, maxAge = _ref6.maxAge;

        _this6.loadMatches();

        return Promise.resolve(_this6.loadData({
          maxAge: maxAge
        })).then($return, $error);
      });
    };

    _this6.startPending = function () {
      return new Promise(function ($return, $error) {
        _this6.matches.forEach(function (match) {
          return match.startPending == null ? void 0 : match.startPending();
        });

        return $return();
      });
    };

    _this6.router = router;
    _this6.location = nextLocation;
    _this6.matches = [];

    _this6.loadMatches();

    return _this6;
  }

  return MatchLoader;
}(Subscribable);

export function useRouter() {
  var value = React.useContext(routerContext);

  if (!value) {
    process.env.NODE_ENV !== "production" ? warning(true, 'You are trying to use useRouter() outside of ReactLocation!') : void 0;
    throw new Error();
  }

  return value.router;
}
export function matchRoutes(router, currentLocation) {
  var _router$routes;

  if (!((_router$routes = router.routes) != null && _router$routes.length)) {
    return [];
  }

  var matches = [];

  var recurse = function recurse(routes, parentMatch) {
    return new Promise(function ($return, $error) {
      var _originalRoute$pendin, _originalRoute$pendin2, _originalRoute$childr;

      var pathname = parentMatch.pathname,
          params = parentMatch.params;
      var filteredRoutes = router != null && router.filterRoutes ? router == null ? void 0 : router.filterRoutes(routes) : routes;
      var routeIndex = -1;
      var originalRoute = filteredRoutes.find(function (route, index) {
        var _route$children;

        var fullRoutePathName = joinPaths([pathname, route.path]);
        var fuzzy = !!(route.path !== '/' || (_route$children = route.children) != null && _route$children.length);
        var matchParams = matchRoute(currentLocation, {
          to: fullRoutePathName,
          search: route.search,
          fuzzy: fuzzy
        });

        if (matchParams) {
          routeIndex = index;
          params = _extends({}, params, matchParams);
        }

        return !!matchParams;
      });

      if (!originalRoute) {
        return $return();
      }

      var interpolatedPathSegments = parsePathname(originalRoute.path);
      var interpolatedPath = joinPaths(interpolatedPathSegments.map(function (segment) {
        if (segment.value === '*') {
          return '';
        }

        if (segment.type === 'param') {
          var _segment$value$substr;

          return (_segment$value$substr = params[segment.value.substring(1)]) != null ? _segment$value$substr : '';
        }

        return segment.value;
      }));
      pathname = joinPaths([pathname, interpolatedPath]);
      var id = joinPaths([parentMatch.id === 'root' ? '' : parentMatch.id, interpolatedPath + "-" + routeIndex.toString()]);
      var match = {
        id: id,
        route: _extends({}, originalRoute, {
          pendingMs: (_originalRoute$pendin = originalRoute.pendingMs) != null ? _originalRoute$pendin : router == null ? void 0 : router.defaultPendingMs,
          pendingMinMs: (_originalRoute$pendin2 = originalRoute.pendingMinMs) != null ? _originalRoute$pendin2 : router == null ? void 0 : router.defaultPendingMinMs
        }),
        routeIndex: routeIndex,
        params: params,
        pathname: pathname,
        search: currentLocation.search
      };
      matches.push(match);

      if ((_originalRoute$childr = originalRoute.children) != null && _originalRoute$childr.length) {
        recurse(originalRoute.children, match);
      }

      return $return();
    });
  };

  recurse(router.routes, router.rootMatch);
  return matches;
}
export function useLoadRoute() {
  var location = useLocation();
  var match = useMatch();
  var router = useRouter();
  var buildNext = useBuildNext();
  return useLatestCallback(function (navigate, opts) {
    return new Promise(function ($return, $error) {
      var _navigate$from, next, matchLoader;

      if (navigate === void 0) {
        navigate = location.current;
      }

      next = buildNext(_extends({}, navigate, {
        from: (_navigate$from = navigate.from) != null ? _navigate$from : {
          pathname: match.pathname
        }
      }));
      matchLoader = router.getMatchLoader(next);
      return Promise.resolve(matchLoader.load(opts)).then($return, $error);
    });
  });
}
export function useParentMatches() {
  var router = useRouter();
  var match = useMatch();
  var matches = router.state.matches;
  return matches.slice(0, matches.findIndex(function (d) {
    return d.id === match.id;
  }) - 1);
}
export function useMatches() {
  return React.useContext(MatchesContext);
}
export function useMatch() {
  var _useMatches;

  return (_useMatches = useMatches()) == null ? void 0 : _useMatches[0];
}
export function useNavigate() {
  var location = useLocation();
  var match = useMatch();
  var buildNext = useBuildNext();

  function navigate(_ref7) {
    var _fromCurrent;

    var search = _ref7.search,
        hash = _ref7.hash,
        replace = _ref7.replace,
        from = _ref7.from,
        to = _ref7.to,
        fromCurrent = _ref7.fromCurrent;
    fromCurrent = (_fromCurrent = fromCurrent) != null ? _fromCurrent : typeof to === 'undefined';
    var next = buildNext({
      to: to,
      search: search,
      hash: hash,
      from: fromCurrent ? location.current : from != null ? from : {
        pathname: match.pathname
      }
    });
    location.navigate(next, replace);
  }

  return useLatestCallback(navigate);
}
export function Navigate(options) {
  var navigate = useNavigate();
  useLayoutEffect(function () {
    navigate(options);
  }, [navigate]);
  return null;
}

function useBuildNext() {
  var location = useLocation();
  var router = useRouter();

  var buildNext = function buildNext(opts) {
    var next = location.buildNext(router.basepath, opts);
    var matches = matchRoutes(router, next);

    var __searchFilters = matches.map(function (match) {
      var _match$route$searchFi;

      return (_match$route$searchFi = match.route.searchFilters) != null ? _match$route$searchFi : [];
    }).flat().filter(Boolean);

    return location.buildNext(router.basepath, _extends({}, opts, {
      __searchFilters: __searchFilters
    }));
  };

  return useLatestCallback(buildNext);
}

export var Link = function Link(_ref8) {
  var _preload;

  var _ref8$to = _ref8.to,
      to = _ref8$to === void 0 ? '.' : _ref8$to,
      search = _ref8.search,
      hash = _ref8.hash,
      children = _ref8.children,
      target = _ref8.target,
      _ref8$style = _ref8.style,
      style = _ref8$style === void 0 ? {} : _ref8$style,
      replace = _ref8.replace,
      onClick = _ref8.onClick,
      onMouseEnter = _ref8.onMouseEnter,
      _ref8$className = _ref8.className,
      className = _ref8$className === void 0 ? '' : _ref8$className,
      _ref8$getActiveProps = _ref8.getActiveProps,
      getActiveProps = _ref8$getActiveProps === void 0 ? function () {
    return {};
  } : _ref8$getActiveProps,
      activeOptions = _ref8.activeOptions,
      preload = _ref8.preload,
      disabled = _ref8.disabled,
      _ref = _ref8._ref,
      rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);

  var loadRoute = useLoadRoute();
  var match = useMatch();
  var location = useLocation();
  var router = useRouter();
  var navigate = useNavigate();
  var buildNext = useBuildNext();
  preload = (_preload = preload) != null ? _preload : router.defaultLinkPreloadMaxAge; // If this `to` is a valid external URL, log a warning

  try {
    var url = new URL("" + to);
    process.env.NODE_ENV !== "production" ? warning(false, "<Link /> should not be used for external URLs like: " + url.href) : void 0;
  } catch (e) {}

  var next = buildNext({
    to: to,
    search: search,
    hash: hash,
    from: {
      pathname: match.pathname
    }
  }); // The click handler

  var handleClick = function handleClick(e) {
    if (onClick) onClick(e);

    if (!isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {
      e.preventDefault(); // All is well? Navigate!

      navigate({
        to: to,
        search: search,
        hash: hash,
        replace: replace,
        from: {
          pathname: match.pathname
        }
      });
    }
  }; // The click handler


  var handleMouseEnter = function handleMouseEnter(e) {
    if (onMouseEnter) onMouseEnter(e);

    if (preload && preload > 0) {
      loadRoute({
        to: to,
        search: search,
        hash: hash
      }, {
        maxAge: preload
      });
    }
  }; // Compare path/hash for matches


  var pathIsEqual = location.current.pathname === next.pathname;
  var currentPathSplit = location.current.pathname.split('/');
  var nextPathSplit = next.pathname.split('/');
  var pathIsFuzzyEqual = nextPathSplit.every(function (d, i) {
    return d === currentPathSplit[i];
  });
  var hashIsEqual = location.current.hash === next.hash; // Combine the matches based on user options

  var pathTest = activeOptions != null && activeOptions.exact ? pathIsEqual : pathIsFuzzyEqual;
  var hashTest = activeOptions != null && activeOptions.includeHash ? hashIsEqual : true; // The final "active" test

  var isActive = pathTest && hashTest; // Get the active props

  var _ref9 = isActive ? getActiveProps() : {},
      _ref9$style = _ref9.style,
      activeStyle = _ref9$style === void 0 ? {} : _ref9$style,
      _ref9$className = _ref9.className,
      activeClassName = _ref9$className === void 0 ? '' : _ref9$className,
      activeRest = _objectWithoutPropertiesLoose(_ref9, _excluded3);

  return /*#__PURE__*/React.createElement("a", _extends({
    ref: _ref,
    href: disabled ? undefined : next.href,
    onClick: handleClick,
    onMouseEnter: handleMouseEnter,
    target: target,
    style: _extends({}, style, activeStyle),
    className: [className, activeClassName].filter(Boolean).join(' ') || undefined
  }, disabled ? {
    role: 'link',
    'aria-disabled': true
  } : undefined, rest, activeRest, {
    children: typeof children === 'function' ? children({
      isActive: isActive
    }) : children
  }));
};
export function Outlet() {
  var _match$errorElement;

  var router = useRouter();

  var _useMatches2 = useMatches(),
      _ = _useMatches2[0],
      matches = _useMatches2.slice(1);

  var match = matches[0];

  if (!match) {
    return null;
  }

  var errorElement = (_match$errorElement = match.errorElement) != null ? _match$errorElement : router.defaultErrorElement;

  var element = function () {
    var _match$pendingElement, _match$element;

    if (match.status === 'rejected') {
      if (errorElement) {
        return errorElement;
      }

      if (!router.useErrorBoundary) {
        if (process.env.NODE_ENV !== 'production') {
          var preStyle = {
            whiteSpace: 'normal',
            display: 'inline-block',
            background: 'rgba(0,0,0,.1)',
            padding: '.1rem .2rem',
            margin: '.1rem',
            lineHeight: '1',
            borderRadius: '.25rem'
          };
          return /*#__PURE__*/React.createElement("div", {
            style: {
              lineHeight: '1.7'
            }
          }, /*#__PURE__*/React.createElement("strong", null, "The following error occured in the loader for you route at:", ' ', /*#__PURE__*/React.createElement("pre", {
            style: preStyle
          }, match.pathname)), ".", /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement("pre", {
            style: _extends({}, preStyle, {
              display: 'block',
              padding: '.5rem',
              borderRadius: '.5rem'
            })
          }, match.error.toString()), /*#__PURE__*/React.createElement("br", null), "Your users won't see this message in production, but they will see", ' ', /*#__PURE__*/React.createElement("strong", null, "\"An unknown error occured!\""), ", which is at least better than breaking your entire app. \uD83D\uDE0A For a better UX, please specify an ", /*#__PURE__*/React.createElement("pre", {
            style: preStyle
          }, "errorElement"), " for all of your routes that contain asynchronous behavior, or at least provide your own", /*#__PURE__*/React.createElement("pre", {
            style: preStyle
          }, "ErrorBoundary"), " wrapper around your renders to both the elements rendered by", ' ', /*#__PURE__*/React.createElement("pre", {
            style: preStyle
          }, 'useRoutes(routes, { useErrorBoundary: true })'), ' ', "and ", /*#__PURE__*/React.createElement("pre", {
            style: preStyle
          }, '<Router useErrorBoundary />'), ".", ' ', /*#__PURE__*/React.createElement("br", null), /*#__PURE__*/React.createElement("br", null));
        }

        return 'An unknown error occured!';
      }

      throw match.error;
    }

    var pendingElement = (_match$pendingElement = match.pendingElement) != null ? _match$pendingElement : router.defaultPendingElement;

    if (match.status === 'pending') {
      if (match.route.pendingMs || pendingElement) {
        return pendingElement != null ? pendingElement : null;
      }
    }

    var matchElement = (_match$element = match.element) != null ? _match$element : router.defaultElement;
    return matchElement ? /*#__PURE__*/React.createElement(React.Fragment, null, matchElement) : /*#__PURE__*/React.createElement(Outlet, null);
  }();

  return /*#__PURE__*/React.createElement(MatchesProvider, {
    value: matches
  }, element);
}
export function useResolvePath() {
  var router = useRouter();
  var match = useMatch();
  return useLatestCallback(function (path) {
    return resolvePath(router.basepath, match.pathname, cleanPath(path));
  });
}
export function useSearch() {
  var location = useLocation();
  return location.current.search;
}
export function matchRoute(currentLocation, matchLocation) {
  var pathParams = matchByPath(currentLocation, matchLocation);
  var searchMatched = matchBySearch(currentLocation, matchLocation);

  if (matchLocation.to && !pathParams) {
    return;
  }

  if (matchLocation.search && !searchMatched) {
    return;
  }

  return pathParams != null ? pathParams : {};
}
export function useMatchRoute() {
  var router = useRouter();
  var resolvePath = useResolvePath();
  return useLatestCallback(function (_ref10) {
    var pending = _ref10.pending,
        matchLocation = _objectWithoutPropertiesLoose(_ref10, _excluded4);

    matchLocation = _extends({}, matchLocation, {
      to: matchLocation.to ? resolvePath("" + matchLocation.to) : undefined
    });

    if (pending) {
      var _router$pending;

      if (!((_router$pending = router.pending) != null && _router$pending.location)) {
        return undefined;
      }

      return matchRoute(router.pending.location, matchLocation);
    }

    return matchRoute(router.state.location, matchLocation);
  });
}
export function MatchRoute(_ref11) {
  var children = _ref11.children,
      rest = _objectWithoutPropertiesLoose(_ref11, _excluded5);

  var matchRoute = useMatchRoute();
  var match = matchRoute(rest);

  if (typeof children === 'function') {
    return children(match);
  }

  return match ? children : null;
}
export function usePrompt(message, when) {
  var location = useLocation();
  React.useEffect(function () {
    if (!when) return;
    var unblock = location.history.block(function (transition) {
      if (window.confirm(message)) {
        unblock();
        transition.retry();
      } else {
        location.current.pathname = window.location.pathname;
      }
    });
    return unblock;
  }, [when, location, message]);
}
export function Prompt(_ref12) {
  var message = _ref12.message,
      when = _ref12.when,
      children = _ref12.children;
  usePrompt(message, when != null ? when : true);
  return children != null ? children : null;
}

function warning(cond, message) {
  if (!cond) {
    if (typeof console !== 'undefined') console.warn(message);

    try {
      throw new Error(message);
    } catch (_unused) {}
  }
}

function isFunction(d) {
  return typeof d === 'function';
}

export function functionalUpdate(updater, previous) {
  if (isFunction(updater)) {
    return updater(previous);
  }

  return updater;
}

function joinPaths(paths) {
  return cleanPath(paths.filter(Boolean).join('/'));
}

export function cleanPath(path) {
  // remove double slashes
  return ("" + path).replace(/\/{2,}/g, '/');
}
export function matchByPath(currentLocation, matchLocation) {
  var _matchLocation$to;

  var baseSegments = parsePathname(currentLocation.pathname);
  var routeSegments = parsePathname("" + ((_matchLocation$to = matchLocation.to) != null ? _matchLocation$to : '*')); // console.log(baseSegments, routeSegments)

  var params = {};

  var isMatch = function () {
    for (var i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
      var baseSegment = baseSegments[i];
      var routeSegment = routeSegments[i];
      var isLastRouteSegment = i === routeSegments.length - 1;
      var isLastBaseSegment = i === baseSegments.length - 1;

      if (routeSegment) {
        if (routeSegment.type === 'wildcard') {
          if (baseSegment != null && baseSegment.value) {
            params['*'] = joinPaths(baseSegments.slice(i).map(function (d) {
              return d.value;
            }));
            return true;
          }

          return false;
        }

        if (routeSegment.type === 'pathname') {
          if (routeSegment.value === '/' && !(baseSegment != null && baseSegment.value)) {
            return true;
          }

          if (baseSegment) {
            if (routeSegment.value !== baseSegment.value) {
              return false;
            }
          }
        }

        if (!baseSegment) {
          return false;
        }

        if (routeSegment.type === 'param') {
          params[routeSegment.value.substring(1)] = baseSegment.value;
        }
      }

      if (isLastRouteSegment && !isLastBaseSegment) {
        return !!matchLocation.fuzzy;
      }
    }

    return true;
  }();

  return isMatch ? params : undefined;
}

function matchBySearch(currentLocation, matchLocation) {
  return !!(matchLocation.search && matchLocation.search(currentLocation.search));
}

export function parsePathname(pathname) {
  if (!pathname) {
    return [];
  }

  pathname = cleanPath(pathname);
  var segments = [];

  if (pathname.slice(0, 1) === '/') {
    pathname = pathname.substring(1);
    segments.push({
      type: 'pathname',
      value: '/'
    });
  }

  if (!pathname) {
    return segments;
  } // Remove empty segments and '.' segments


  var split = pathname.split('/').filter(Boolean);
  segments.push.apply(segments, split.map(function (part) {
    if (part.startsWith('*')) {
      return {
        type: 'wildcard',
        value: part
      };
    }

    if (part.charAt(0) === ':') {
      return {
        type: 'param',
        value: part
      };
    }

    return {
      type: 'pathname',
      value: part
    };
  }));

  if (pathname.slice(-1) === '/') {
    pathname = pathname.substring(1);
    segments.push({
      type: 'pathname',
      value: '/'
    });
  }

  return segments;
}

function resolvePath(basepath, base, to) {
  base = base.replace(new RegExp("^" + basepath), '/');
  to = to.replace(new RegExp("^" + basepath), '/');
  var baseSegments = parsePathname(base);
  var toSegments = parsePathname(to);
  toSegments.forEach(function (toSegment, index) {
    if (toSegment.value === '/') {
      if (!index) {
        baseSegments = [toSegment];
      } else {// ignore inter-slashes
      }
    } else if (toSegment.value === '..') {
      baseSegments.pop();
    } else if (toSegment.value === '.') {
      return;
    } else {
      baseSegments.push(toSegment);
    }
  });
  var joined = joinPaths([basepath].concat(baseSegments.map(function (d) {
    return d.value;
  })));
  return cleanPath(joined);
}

function isCtrlEvent(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}

function useLatestCallback(cb) {
  var stableFnRef = React.useRef();
  var cbRef = React.useRef(cb);
  cbRef.current = cb;

  if (!stableFnRef.current) {
    stableFnRef.current = function () {
      return cbRef.current.apply(cbRef, arguments);
    };
  }

  return stableFnRef.current;
}

function useGetIsMounted() {
  var ref = React.useRef(false);
  React.useEffect(function () {
    ref.current = true;
    return function () {
      ref.current = false;
    };
  });
  return function () {
    return ref.current;
  };
}
/**
 * This function returns `a` if `b` is deeply equal.
 * If not, it will replace any deeply equal children of `b` with those of `a`.
 * This can be used for structural sharing between JSON values for example.
 */


function replaceEqualDeep(prev, next) {
  if (prev === next) {
    return prev;
  }

  var array = Array.isArray(prev) && Array.isArray(next);

  if (array || isPlainObject(prev) && isPlainObject(next)) {
    var aSize = array ? prev.length : Object.keys(prev).length;
    var bItems = array ? next : Object.keys(next);
    var bSize = bItems.length;
    var copy = array ? [] : {};
    var equalItems = 0;

    for (var i = 0; i < bSize; i++) {
      var key = array ? i : bItems[i];
      copy[key] = replaceEqualDeep(prev[key], next[key]);

      if (copy[key] === prev[key]) {
        equalItems++;
      }
    }

    return aSize === bSize && equalItems === aSize ? prev : copy;
  }

  return next;
} // Copied from: https://github.com/jonschlinkert/is-plain-object


function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  } // If has modified constructor


  var ctor = o.constructor;

  if (typeof ctor === 'undefined') {
    return true;
  } // If has modified prototype


  var prot = ctor.prototype;

  if (!hasObjectPrototype(prot)) {
    return false;
  } // If constructor does not have an Object-specific method


  if (!prot.hasOwnProperty('isPrototypeOf')) {
    return false;
  } // Most likely a plain Object


  return true;
}

function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

export function defaultStringifySearch(search) {
  search = _extends({}, search);

  if (search) {
    Object.keys(search).forEach(function (key) {
      var val = search[key];

      if (typeof val === 'undefined' || val === undefined) {
        delete search[key];
      } else if (val && typeof val === 'object' && val !== null) {
        try {
          search[key] = JSON.stringify(val);
        } catch (err) {// silent
        }
      }
    });
  }

  var searchStr = new URLSearchParams(search).toString();
  return searchStr ? "?" + searchStr : '';
}
export function defaultParseSearch(searchStr) {
  if (searchStr.substring(0, 1) === '?') {
    searchStr = searchStr.substring(1);
  }

  var query = Object.fromEntries(new URLSearchParams(searchStr).entries()); // Try to parse query params

  for (var key in query) {
    var value = query[key];

    try {
      query[key] = JSON.parse(value);
    } catch (err) {//
    }
  }

  return query;
}