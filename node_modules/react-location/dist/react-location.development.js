(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.ReactLocation = {}, global.React));
})(this, (function (exports, React) { 'use strict';

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespace(React);

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  var r,
      B = r || (r = {});
  B.Pop = "POP";
  B.Push = "PUSH";
  B.Replace = "REPLACE";
  var C = function (b) {
    return Object.freeze(b);
  } ;

  function D(b, h) {
    if (!b) {
      "undefined" !== typeof console && console.warn(h);

      try {
        throw Error(h);
      } catch (k) {}
    }
  }

  function E(b) {
    b.preventDefault();
    b.returnValue = "";
  }

  function F() {
    var b = [];
    return {
      get length() {
        return b.length;
      },

      push: function (h) {
        b.push(h);
        return function () {
          b = b.filter(function (k) {
            return k !== h;
          });
        };
      },
      call: function (h) {
        b.forEach(function (k) {
          return k && k(h);
        });
      }
    };
  }

  function H() {
    return Math.random().toString(36).substr(2, 8);
  }

  function I(b) {
    var h = b.pathname,
        k = b.search;
    b = b.hash;
    return (void 0 === h ? "/" : h) + (void 0 === k ? "" : k) + (void 0 === b ? "" : b);
  }

  function J(b) {
    var h = {};

    if (b) {
      var k = b.indexOf("#");
      0 <= k && (h.hash = b.substr(k), b = b.substr(0, k));
      k = b.indexOf("?");
      0 <= k && (h.search = b.substr(k), b = b.substr(0, k));
      b && (h.pathname = b);
    }

    return h;
  }

  function createBrowserHistory(b) {
    function h() {
      var c = p.location,
          a = m.state || {};
      return [a.idx, C({
        pathname: c.pathname,
        search: c.search,
        hash: c.hash,
        state: a.usr || null,
        key: a.key || "default"
      })];
    }

    function k(c) {
      return "string" === typeof c ? c : I(c);
    }

    function x(c, a) {
      void 0 === a && (a = null);
      return C(_extends({}, q, "string" === typeof c ? J(c) : c, {
        state: a,
        key: H()
      }));
    }

    function z(c) {
      t = c;
      c = h();
      v = c[0];
      q = c[1];
      d.call({
        action: t,
        location: q
      });
    }

    function A(c, a) {
      function e() {
        A(c, a);
      }

      var l = r.Push,
          g = x(c, a);

      if (!f.length || (f.call({
        action: l,
        location: g,
        retry: e
      }), !1)) {
        var n = [{
          usr: g.state,
          key: g.key,
          idx: v + 1
        }, k(g)];
        g = n[0];
        n = n[1];

        try {
          m.pushState(g, "", n);
        } catch (G) {
          p.location.assign(n);
        }

        z(l);
      }
    }

    function y(c, a) {
      function e() {
        y(c, a);
      }

      var l = r.Replace,
          g = x(c, a);
      f.length && (f.call({
        action: l,
        location: g,
        retry: e
      }), 1) || (g = [{
        usr: g.state,
        key: g.key,
        idx: v
      }, k(g)], m.replaceState(g[0], "", g[1]), z(l));
    }

    function w(c) {
      m.go(c);
    }

    void 0 === b && (b = {});
    b = b.window;
    var p = void 0 === b ? document.defaultView : b,
        m = p.history,
        u = null;
    p.addEventListener("popstate", function () {
      if (u) f.call(u), u = null;else {
        var c = r.Pop,
            a = h(),
            e = a[0];
        a = a[1];
        if (f.length) {
          if (null != e) {
            var l = v - e;
            l && (u = {
              action: c,
              location: a,
              retry: function () {
                w(-1 * l);
              }
            }, w(l));
          } else D(!1, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") ;
        } else z(c);
      }
    });
    var t = r.Pop;
    b = h();
    var v = b[0],
        q = b[1],
        d = F(),
        f = F();
    null == v && (v = 0, m.replaceState(_extends({}, m.state, {
      idx: v
    }), ""));
    return {
      get action() {
        return t;
      },

      get location() {
        return q;
      },

      createHref: k,
      push: A,
      replace: y,
      go: w,
      back: function () {
        w(-1);
      },
      forward: function () {
        w(1);
      },
      listen: function (c) {
        return d.push(c);
      },
      block: function (c) {
        var a = f.push(c);
        1 === f.length && p.addEventListener("beforeunload", E);
        return function () {
          a();
          f.length || p.removeEventListener("beforeunload", E);
        };
      }
    };
  }

  function createHashHistory(b) {
    function h() {
      var a = J(m.location.hash.substr(1)),
          e = a.pathname,
          l = a.search;
      a = a.hash;
      var g = u.state || {};
      return [g.idx, C({
        pathname: void 0 === e ? "/" : e,
        search: void 0 === l ? "" : l,
        hash: void 0 === a ? "" : a,
        state: g.usr || null,
        key: g.key || "default"
      })];
    }

    function k() {
      if (t) c.call(t), t = null;else {
        var a = r.Pop,
            e = h(),
            l = e[0];
        e = e[1];
        if (c.length) {
          if (null != l) {
            var g = q - l;
            g && (t = {
              action: a,
              location: e,
              retry: function () {
                p(-1 * g);
              }
            }, p(g));
          } else D(!1, "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") ;
        } else A(a);
      }
    }

    function x(a) {
      var e = document.querySelector("base"),
          l = "";
      e && e.getAttribute("href") && (e = m.location.href, l = e.indexOf("#"), l = -1 === l ? e : e.slice(0, l));
      return l + "#" + ("string" === typeof a ? a : I(a));
    }

    function z(a, e) {
      void 0 === e && (e = null);
      return C(_extends({}, d, "string" === typeof a ? J(a) : a, {
        state: e,
        key: H()
      }));
    }

    function A(a) {
      v = a;
      a = h();
      q = a[0];
      d = a[1];
      f.call({
        action: v,
        location: d
      });
    }

    function y(a, e) {
      function l() {
        y(a, e);
      }

      var g = r.Push,
          n = z(a, e);
      D("/" === n.pathname.charAt(0), "Relative pathnames are not supported in hash history.push(" + JSON.stringify(a) + ")") ;

      if (!c.length || (c.call({
        action: g,
        location: n,
        retry: l
      }), !1)) {
        var G = [{
          usr: n.state,
          key: n.key,
          idx: q + 1
        }, x(n)];
        n = G[0];
        G = G[1];

        try {
          u.pushState(n, "", G);
        } catch (K) {
          m.location.assign(G);
        }

        A(g);
      }
    }

    function w(a, e) {
      function l() {
        w(a, e);
      }

      var g = r.Replace,
          n = z(a, e);
      D("/" === n.pathname.charAt(0), "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(a) + ")") ;
      c.length && (c.call({
        action: g,
        location: n,
        retry: l
      }), 1) || (n = [{
        usr: n.state,
        key: n.key,
        idx: q
      }, x(n)], u.replaceState(n[0], "", n[1]), A(g));
    }

    function p(a) {
      u.go(a);
    }

    void 0 === b && (b = {});
    b = b.window;
    var m = void 0 === b ? document.defaultView : b,
        u = m.history,
        t = null;
    m.addEventListener("popstate", k);
    m.addEventListener("hashchange", function () {
      var a = h()[1];
      I(a) !== I(d) && k();
    });
    var v = r.Pop;
    b = h();
    var q = b[0],
        d = b[1],
        f = F(),
        c = F();
    null == q && (q = 0, u.replaceState(_extends({}, u.state, {
      idx: q
    }), ""));
    return {
      get action() {
        return v;
      },

      get location() {
        return d;
      },

      createHref: x,
      push: y,
      replace: w,
      go: p,
      back: function () {
        p(-1);
      },
      forward: function () {
        p(1);
      },
      listen: function (a) {
        return f.push(a);
      },
      block: function (a) {
        var e = c.push(a);
        1 === c.length && m.addEventListener("beforeunload", E);
        return function () {
          e();
          c.length || m.removeEventListener("beforeunload", E);
        };
      }
    };
  }

  function createMemoryHistory(b) {
    function h(d, f) {
      void 0 === f && (f = null);
      return C(_extends({}, t, "string" === typeof d ? J(d) : d, {
        state: f,
        key: H()
      }));
    }

    function k(d, f, c) {
      return !q.length || (q.call({
        action: d,
        location: f,
        retry: c
      }), !1);
    }

    function x(d, f) {
      u = d;
      t = f;
      v.call({
        action: u,
        location: t
      });
    }

    function z(d, f) {
      var c = r.Push,
          a = h(d, f);
      D("/" === t.pathname.charAt(0), "Relative pathnames are not supported in memory history.push(" + JSON.stringify(d) + ")") ;
      k(c, a, function () {
        z(d, f);
      }) && (m += 1, p.splice(m, p.length, a), x(c, a));
    }

    function A(d, f) {
      var c = r.Replace,
          a = h(d, f);
      D("/" === t.pathname.charAt(0), "Relative pathnames are not supported in memory history.replace(" + JSON.stringify(d) + ")") ;
      k(c, a, function () {
        A(d, f);
      }) && (p[m] = a, x(c, a));
    }

    function y(d) {
      var f = Math.min(Math.max(m + d, 0), p.length - 1),
          c = r.Pop,
          a = p[f];
      k(c, a, function () {
        y(d);
      }) && (m = f, x(c, a));
    }

    void 0 === b && (b = {});
    var w = b;
    b = w.initialEntries;
    w = w.initialIndex;
    var p = (void 0 === b ? ["/"] : b).map(function (d) {
      var f = C(_extends({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: H()
      }, "string" === typeof d ? J(d) : d));
      D("/" === f.pathname.charAt(0), "Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: " + JSON.stringify(d) + ")") ;
      return f;
    }),
        m = Math.min(Math.max(null == w ? p.length - 1 : w, 0), p.length - 1),
        u = r.Pop,
        t = p[m],
        v = F(),
        q = F();
    return {
      get index() {
        return m;
      },

      get action() {
        return u;
      },

      get location() {
        return t;
      },

      createHref: function (d) {
        return "string" === typeof d ? d : I(d);
      },
      push: z,
      replace: A,
      go: y,
      back: function () {
        y(-1);
      },
      forward: function () {
        y(1);
      },
      listen: function (d) {
        return v.push(d);
      },
      block: function (d) {
        return q.push(d);
      }
    };
  }

  var _excluded = ["children", "location"],
      _excluded2 = ["to", "search", "hash", "children", "target", "style", "replace", "onClick", "onMouseEnter", "className", "getActiveProps", "activeOptions", "preload", "disabled", "_ref"],
      _excluded3 = ["style", "className"],
      _excluded4 = ["pending"],
      _excluded5 = ["children"];

  // Source
  var LocationContext = /*#__PURE__*/React__namespace.createContext(null);
  var MatchesContext = /*#__PURE__*/React__namespace.createContext(null);
  var routerContext = /*#__PURE__*/React__namespace.createContext(null); // Detect if we're in the DOM

  var isDOM = Boolean(typeof window !== 'undefined' && window.document && window.document.createElement);
  var useLayoutEffect = isDOM ? React__namespace.useLayoutEffect : React__namespace.useEffect; // This is the default history object if none is defined

  var createDefaultHistory = function createDefaultHistory() {
    return isDOM ? createBrowserHistory() : createMemoryHistory();
  };

  var Subscribable = /*#__PURE__*/function () {
    function Subscribable() {
      this.listeners = [];
    }

    var _proto = Subscribable.prototype;

    _proto.subscribe = function subscribe(listener) {
      var _this = this;

      this.listeners.push(listener);
      return function () {
        _this.listeners = _this.listeners.filter(function (x) {
          return x !== listener;
        });
      };
    };

    _proto.notify = function notify(payload) {
      this.listeners.forEach(function (listener) {
        return listener(payload);
      });
    };

    return Subscribable;
  }();

  var ReactLocation = /*#__PURE__*/function (_Subscribable) {
    _inheritsLoose(ReactLocation, _Subscribable);

    //
    function ReactLocation(options) {
      var _options$stringifySea, _options$parseSearch;

      var _this2;

      _this2 = _Subscribable.call(this) || this;
      _this2.isTransitioning = false;
      _this2.history = (options == null ? void 0 : options.history) || createDefaultHistory();
      _this2.stringifySearch = (_options$stringifySea = options == null ? void 0 : options.stringifySearch) != null ? _options$stringifySea : defaultStringifySearch;
      _this2.parseSearch = (_options$parseSearch = options == null ? void 0 : options.parseSearch) != null ? _options$parseSearch : defaultParseSearch;
      _this2.current = _this2.parseLocation(_this2.history.location);
      _this2.destroy = _this2.history.listen(function (event) {
        _this2.current = _this2.parseLocation(event.location, _this2.current);

        _this2.notify();
      });
      return _this2;
    }

    var _proto2 = ReactLocation.prototype;

    _proto2.buildNext = function buildNext(basepath, dest) {
      var _dest$to, _ref2, _dest$__searchFilters;

      if (basepath === void 0) {
        basepath = '/';
      }

      if (dest === void 0) {
        dest = {};
      }

      var from = _extends$1({}, this.current, dest.from);

      var pathname = resolvePath(basepath, from.pathname, "" + ((_dest$to = dest.to) != null ? _dest$to : '.'));
      var updatedSearch = (_ref2 = dest.search === true ? from.search : functionalUpdate(dest.search, from.search)) != null ? _ref2 : {};
      var filteredSearch = (_dest$__searchFilters = dest.__searchFilters) != null && _dest$__searchFilters.length ? dest.__searchFilters.reduce(function (prev, next) {
        return next(prev, updatedSearch);
      }, from.search) : updatedSearch;
      var search = replaceEqualDeep(from.search, filteredSearch);
      var searchStr = this.stringifySearch(search);
      var hash = functionalUpdate(dest.hash, from.hash);
      hash = hash ? "#" + hash : '';
      return {
        pathname: pathname,
        search: search,
        searchStr: searchStr,
        hash: hash,
        href: "" + pathname + searchStr + hash,
        key: dest.key
      };
    };

    _proto2.navigate = function navigate(next, replace) {
      var _this3 = this;

      this.current = next;
      if (this.navigateTimeout) clearTimeout(this.navigateTimeout);
      var nextAction = 'replace';

      if (!this.nextAction) {
        nextAction = replace ? 'replace' : 'push';
      }

      if (!replace) {
        nextAction = 'push';
      }

      this.nextAction = nextAction;
      this.navigateTimeout = setTimeout(function () {
        var nextAction = _this3.nextAction;
        delete _this3.nextAction;

        var isSameUrl = _this3.parseLocation(_this3.history.location).href === _this3.current.href;

        if (isSameUrl && !_this3.current.key) {
          nextAction = 'replace';
        }

        if (nextAction === 'replace') {
          return _this3.history.replace({
            pathname: _this3.current.pathname,
            hash: _this3.current.hash,
            search: _this3.current.searchStr
          });
        }

        return _this3.history.push({
          pathname: _this3.current.pathname,
          hash: _this3.current.hash,
          search: _this3.current.searchStr
        });
      }, 16);
    };

    _proto2.parseLocation = function parseLocation(location, previousLocation) {
      var _location$hash$split$;

      var parsedSearch = this.parseSearch(location.search);
      return {
        pathname: location.pathname,
        searchStr: location.search,
        search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
        hash: (_location$hash$split$ = location.hash.split('#').reverse()[0]) != null ? _location$hash$split$ : '',
        href: "" + location.pathname + location.search + location.hash,
        key: location.key
      };
    };

    return ReactLocation;
  }(Subscribable);
  function MatchesProvider(props) {
    return /*#__PURE__*/React__namespace.createElement(MatchesContext.Provider, props);
  }
  function Router(_ref3) {
    var children = _ref3.children,
        location = _ref3.location,
        rest = _objectWithoutPropertiesLoose(_ref3, _excluded);

    var routerRef = React__namespace.useRef(null);

    if (!routerRef.current) {
      routerRef.current = new RouterInstance(_extends$1({}, rest, {
        location: location
      }));
    }

    var router = routerRef.current;

    var _React$useReducer = React__namespace.useReducer(function () {
      return {};
    }, {}),
        nonce = _React$useReducer[0],
        rerender = _React$useReducer[1];

    useLayoutEffect(function () {
      return router.subscribe(rerender);
    }, []);
    useLayoutEffect(function () {
      return router.updateLocation(location.current).unsubscribe;
    }, [location.current.key]);
    var routerValue = React__namespace.useMemo(function () {
      return {
        router: router
      };
    }, [nonce]);
    return /*#__PURE__*/React__namespace.createElement(LocationContext.Provider, {
      value: location
    }, /*#__PURE__*/React__namespace.createElement(routerContext.Provider, {
      value: routerValue
    }, /*#__PURE__*/React__namespace.createElement(MatchesProvider, {
      value: [router.rootMatch].concat(router.state.matches)
    }, children)));
  }
  var RouterInstance = /*#__PURE__*/function (_Subscribable2) {
    _inheritsLoose(RouterInstance, _Subscribable2);

    function RouterInstance(opts) {
      var _opts$basepath, _opts$initialMatches;

      var _this4;

      _this4 = _Subscribable2.call(this) || this;

      _this4.setState = function (updater) {
        var newState = updater({
          state: _this4.state,
          pending: _this4.pending
        });
        _this4.state = newState.state;
        _this4.pending = newState.pending;

        _this4.cleanMatchCache();

        _this4.notify();
      };

      _this4.matchCache = {};

      _this4.getMatchLoader = function (next) {
        return new MatchLoader(_assertThisInitialized(_this4), next);
      };

      _this4.cleanMatchCache = function () {
        var _assertThisInitialize, _assertThisInitialize2, _assertThisInitialize3, _assertThisInitialize4, _assertThisInitialize5;

        var activeMatchIds = [].concat((_assertThisInitialize = (_assertThisInitialize2 = _assertThisInitialized(_this4)) == null ? void 0 : _assertThisInitialize2.state.matches) != null ? _assertThisInitialize : [], (_assertThisInitialize3 = (_assertThisInitialize4 = _assertThisInitialized(_this4)) == null ? void 0 : (_assertThisInitialize5 = _assertThisInitialize4.pending) == null ? void 0 : _assertThisInitialize5.matches) != null ? _assertThisInitialize3 : []).map(function (d) {
          return d.id;
        });
        Object.values(_this4.matchCache).forEach(function (match) {
          var _match$updatedAt;

          if (!match.updatedAt) {
            return;
          }

          if (activeMatchIds.includes(match.id)) {
            return;
          }

          var age = Date.now() - ((_match$updatedAt = match.updatedAt) != null ? _match$updatedAt : 0);

          if (!match.maxAge || age > match.maxAge) {
            delete _this4.matchCache[match.id];
          }
        });
      };

      _this4.updateLocation = function (next) {
        var unsubscribe;
        var promise = new Promise(function (resolve) {
          var _this4$state$matches;

          var matchLoader = _this4.getMatchLoader(next);

          (_this4$state$matches = _this4.state.matches) == null ? void 0 : _this4$state$matches.forEach(function (match) {
            match.used = true;
          });

          _this4.setState(function (old) {
            return _extends$1({}, old, {
              pending: {
                status: 'pending',
                location: matchLoader.location,
                matches: matchLoader.matches
              }
            });
          });

          unsubscribe = matchLoader.subscribe(function () {
            var currentMatches = _this4.state.matches;
            currentMatches.filter(function (d) {
              return !matchLoader.matches.find(function (dd) {
                return dd.id === d.id;
              });
            }).forEach(function (d) {
              d.onExit == null ? void 0 : d.onExit(d);
            });
            currentMatches.filter(function (d) {
              return matchLoader.matches.find(function (dd) {
                return dd.id === d.id;
              });
            }).forEach(function (d) {
              d.route.onTransition == null ? void 0 : d.route.onTransition(d);
            });
            matchLoader.matches.filter(function (d) {
              return !currentMatches.find(function (dd) {
                return dd.id === d.id;
              });
            }).forEach(function (d) {
              d.onExit = d.route.onMatch == null ? void 0 : d.route.onMatch(d);
            });

            _this4.setState(function (old) {
              return _extends$1({}, old, {
                state: {
                  status: 'ready',
                  location: matchLoader.location,
                  matches: matchLoader.matches
                },
                pending: undefined
              });
            });

            resolve();
          });
          matchLoader.loadData();
          matchLoader.startPending();
        });
        return {
          promise: promise,
          unsubscribe: unsubscribe
        };
      };

      Object.assign(_assertThisInitialized(_this4), opts);
      _this4.basepath = cleanPath("/" + ((_opts$basepath = opts.basepath) != null ? _opts$basepath : ''));
      _this4.rootMatch = {
        id: 'root',
        params: {},
        search: {},
        routeIndex: 0,
        pathname: _this4.basepath,
        route: null,
        data: {},
        isLoading: false,
        status: 'resolved'
      };
      _this4.state = {
        status: 'ready',
        location: opts.location.current,
        matches: (_opts$initialMatches = opts.initialMatches) != null ? _opts$initialMatches : []
      };
      opts.location.subscribe(function () {
        return _this4.notify();
      });
      return _this4;
    }

    return RouterInstance;
  }(Subscribable);
  function useLocation() {
    var getIsMounted = useGetIsMounted();

    var _React$useReducer2 = React__namespace.useReducer(function (d) {
      return d + 1;
    }, 0),
        rerender = _React$useReducer2[1];

    var instance = React__namespace.useContext(LocationContext);
    "development" !== "production" ? warning(!!instance, 'useLocation must be used within a <ReactLocation />') : void 0;
    useLayoutEffect(function () {
      return instance.subscribe(function () {
        // Rerender all subscribers in a microtask
        Promise.resolve().then(function () {
          setTimeout(function renderAllLocationSubscribers() {
            if (getIsMounted()) {
              rerender();
            }
          }, 0);
        });
      });
    }, [instance]);
    return instance;
  }
  var RouteMatch = function RouteMatch(unloadedMatch) {
    var _this5 = this;

    this.status = 'pending';
    this.data = {};
    this.isLoading = false;

    this.notify = function (isSoft) {
      var _this5$matchLoader;

      (_this5$matchLoader = _this5.matchLoader) == null ? void 0 : _this5$matchLoader.notify(isSoft);
    };

    this.assignMatchLoader = function (matchLoader) {
      _this5.matchLoader = matchLoader;
    };

    this.startPending = function () {
      if (_this5.pendingTimeout) {
        clearTimeout(_this5.pendingTimeout);
      }

      if (_this5.route.pendingMs) {
        _this5.pendingTimeout = setTimeout(function () {
          _this5.notify == null ? void 0 : _this5.notify();

          if (typeof _this5.route.pendingMinMs !== 'undefined') {
            _this5.pendingMinPromise = new Promise(function (r) {
              return setTimeout(r, _this5.route.pendingMinMs);
            });
          }
        }, _this5.route.pendingMs);
      }
    };

    this.load = function (opts) {
      var _ref4, _opts$maxAge;

      _this5.maxAge = (_ref4 = (_opts$maxAge = opts.maxAge) != null ? _opts$maxAge : _this5.route.loaderMaxAge) != null ? _ref4 : opts.router.defaultLoaderMaxAge;

      if (_this5.loaderPromise) {
        return;
      }

      var importer = _this5.route.import; // First, run any importers

      _this5.loaderPromise = (!importer ? Promise.resolve() : importer({
        params: _this5.params,
        search: _this5.search
      }).then(function (imported) {
        _this5.route = _extends$1({}, _this5.route, imported);
      }) // then run all element and data loaders in parallel
      ).then(function () {
        var elementPromises = []; // For each element type, potentially load it asynchronously

        var elementTypes = ['element', 'errorElement', 'pendingElement'];
        elementTypes.forEach(function (type) {
          var routeElement = _this5.route[type];

          if (_this5[type]) {
            return;
          }

          if (typeof routeElement === 'function') {
            elementPromises.push(routeElement(_this5).then(function (res) {
              _this5[type] = res;
            }));
          } else {
            _this5[type] = _this5.route[type];
          }
        });
        var loader = _this5.route.loader;
        var dataPromise = !loader ? Promise.resolve().then(function () {
          _this5.status = 'resolved';
        }) : new Promise(function (resolveLoader, rejectLoader) {
          return new Promise(function ($return, $error) {
            var pendingTimeout, resolve, reject, finish;

            resolve = function resolve(data) {
              _this5.status = 'resolved';
              _this5.data = data;
              _this5.error = undefined;
            };

            reject = function reject(err) {
              console.error(err);
              _this5.status = 'rejected';
              _this5.error = err;
              rejectLoader(err);
            };

            finish = function finish() {
              _this5.isLoading = false;
              _this5.startPending = undefined;
              clearTimeout(pendingTimeout);
              resolveLoader(_this5.data);
            };

            var $Try_1_Post = function () {
              try {
                return $return();
              } catch ($boundEx) {
                return $error($boundEx);
              }
            };

            var $Try_1_Catch = function (err) {
              try {
                reject(err);
                finish();
                return $Try_1_Post();
              } catch ($boundEx) {
                return $error($boundEx);
              }
            };

            try {
              _this5.isLoading = true;
              return Promise.resolve(loader(_this5, {
                parentMatch: opts.parentMatch,
                dispatch: function dispatch(event) {
                  return new Promise(function ($return, $error) {
                    if (event.type === 'resolve') {
                      resolve(event.data);
                    } else if (event.type === 'reject') {
                      reject(event.error);
                    } else if (event.type === 'loading') {
                      _this5.isLoading = true;
                    } else if (event.type === 'maxAge') {
                      _this5.maxAge = event.maxAge;
                    }

                    _this5.updatedAt = Date.now();
                    _this5.notify == null ? void 0 : _this5.notify(true);
                    return $return();
                  });
                }
              })).then(function ($await_6) {
                try {
                  resolve($await_6);
                  return Promise.resolve(_this5.pendingMinPromise).then(function ($await_7) {
                    try {
                      finish();
                      return $Try_1_Post();
                    } catch ($boundEx) {
                      return $Try_1_Catch($boundEx);
                    }
                  }, $Try_1_Catch);
                } catch ($boundEx) {
                  return $Try_1_Catch($boundEx);
                }
              }, $Try_1_Catch);
            } catch (err) {
              $Try_1_Catch(err);
            }
          });
        });
        return Promise.all([].concat(elementPromises, [dataPromise])).then(function () {
          _this5.updatedAt = Date.now();
        });
      }).then(function () {
        return _this5.data;
      });
    };

    Object.assign(this, unloadedMatch);
  };

  var MatchLoader = /*#__PURE__*/function (_Subscribable3) {
    _inheritsLoose(MatchLoader, _Subscribable3);

    function MatchLoader(router, nextLocation) {
      var _this6;

      _this6 = _Subscribable3.call(this) || this;
      _this6.status = 'pending';

      _this6.preNotify = function (isSoft) {
        var _this6$matches;

        if (_this6.status === 'pending' && isSoft) {
          return;
        }

        _this6.status = 'resolved';
        (_this6$matches = _this6.matches) == null ? void 0 : _this6$matches.forEach(function (match, index) {
          var _this6$matches2, _parentMatch$data;

          var parentMatch = (_this6$matches2 = _this6.matches) == null ? void 0 : _this6$matches2[index - 1];
          match.data = _extends$1({}, (_parentMatch$data = parentMatch == null ? void 0 : parentMatch.data) != null ? _parentMatch$data : {}, match.data);
        });

        _this6.notify(false);
      };

      _this6.loadMatches = function () {
        var unloadedMatches = matchRoutes(_this6.router, _this6.location);
        _this6.matches = unloadedMatches == null ? void 0 : unloadedMatches.map(function (unloadedMatch) {
          if (!_this6.router.matchCache[unloadedMatch.id]) {
            _this6.router.matchCache[unloadedMatch.id] = new RouteMatch(unloadedMatch);
          }

          return _this6.router.matchCache[unloadedMatch.id];
        });
      };

      _this6.loadData = function (_temp) {
        return new Promise(function ($return, $error) {
          var _this6$matches3, _ref5, maxAge;

          _ref5 = _temp === void 0 ? {} : _temp, maxAge = _ref5.maxAge;

          _this6.loadMatches();

          _this6.router.cleanMatchCache();

          if (!((_this6$matches3 = _this6.matches) != null && _this6$matches3.length)) {
            _this6.preNotify();

            return $return();
          }

          _this6.firstRenderPromises = [];

          _this6.matches.forEach(function (match, index) {
            var _this6$matches4, _this6$firstRenderPro;

            var parentMatch = (_this6$matches4 = _this6.matches) == null ? void 0 : _this6$matches4[index - 1];
            match.assignMatchLoader == null ? void 0 : match.assignMatchLoader(_assertThisInitialized(_this6));
            match.load == null ? void 0 : match.load({
              maxAge: maxAge,
              parentMatch: parentMatch,
              router: _this6.router
            });
            (_this6$firstRenderPro = _this6.firstRenderPromises) == null ? void 0 : _this6$firstRenderPro.push(match.loaderPromise);
          });

          return Promise.resolve(Promise.all(_this6.firstRenderPromises).then(function () {
            _this6.preNotify();

            return _this6.matches;
          })).then($return, $error);
        });
      };

      _this6.load = function (_temp2) {
        return new Promise(function ($return, $error) {
          var _ref6, maxAge;

          _ref6 = _temp2 === void 0 ? {} : _temp2, maxAge = _ref6.maxAge;

          _this6.loadMatches();

          return Promise.resolve(_this6.loadData({
            maxAge: maxAge
          })).then($return, $error);
        });
      };

      _this6.startPending = function () {
        return new Promise(function ($return, $error) {
          _this6.matches.forEach(function (match) {
            return match.startPending == null ? void 0 : match.startPending();
          });

          return $return();
        });
      };

      _this6.router = router;
      _this6.location = nextLocation;
      _this6.matches = [];

      _this6.loadMatches();

      return _this6;
    }

    return MatchLoader;
  }(Subscribable);

  function useRouter() {
    var value = React__namespace.useContext(routerContext);

    if (!value) {
      "development" !== "production" ? warning(true, 'You are trying to use useRouter() outside of ReactLocation!') : void 0;
      throw new Error();
    }

    return value.router;
  }
  function matchRoutes(router, currentLocation) {
    var _router$routes;

    if (!((_router$routes = router.routes) != null && _router$routes.length)) {
      return [];
    }

    var matches = [];

    var recurse = function recurse(routes, parentMatch) {
      return new Promise(function ($return, $error) {
        var _originalRoute$pendin, _originalRoute$pendin2, _originalRoute$childr;

        var pathname = parentMatch.pathname,
            params = parentMatch.params;
        var filteredRoutes = router != null && router.filterRoutes ? router == null ? void 0 : router.filterRoutes(routes) : routes;
        var routeIndex = -1;
        var originalRoute = filteredRoutes.find(function (route, index) {
          var _route$children;

          var fullRoutePathName = joinPaths([pathname, route.path]);
          var fuzzy = !!(route.path !== '/' || (_route$children = route.children) != null && _route$children.length);
          var matchParams = matchRoute(currentLocation, {
            to: fullRoutePathName,
            search: route.search,
            fuzzy: fuzzy
          });

          if (matchParams) {
            routeIndex = index;
            params = _extends$1({}, params, matchParams);
          }

          return !!matchParams;
        });

        if (!originalRoute) {
          return $return();
        }

        var interpolatedPathSegments = parsePathname(originalRoute.path);
        var interpolatedPath = joinPaths(interpolatedPathSegments.map(function (segment) {
          if (segment.value === '*') {
            return '';
          }

          if (segment.type === 'param') {
            var _segment$value$substr;

            return (_segment$value$substr = params[segment.value.substring(1)]) != null ? _segment$value$substr : '';
          }

          return segment.value;
        }));
        pathname = joinPaths([pathname, interpolatedPath]);
        var id = joinPaths([parentMatch.id === 'root' ? '' : parentMatch.id, interpolatedPath + "-" + routeIndex.toString()]);
        var match = {
          id: id,
          route: _extends$1({}, originalRoute, {
            pendingMs: (_originalRoute$pendin = originalRoute.pendingMs) != null ? _originalRoute$pendin : router == null ? void 0 : router.defaultPendingMs,
            pendingMinMs: (_originalRoute$pendin2 = originalRoute.pendingMinMs) != null ? _originalRoute$pendin2 : router == null ? void 0 : router.defaultPendingMinMs
          }),
          routeIndex: routeIndex,
          params: params,
          pathname: pathname,
          search: currentLocation.search
        };
        matches.push(match);

        if ((_originalRoute$childr = originalRoute.children) != null && _originalRoute$childr.length) {
          recurse(originalRoute.children, match);
        }

        return $return();
      });
    };

    recurse(router.routes, router.rootMatch);
    return matches;
  }
  function useLoadRoute() {
    var location = useLocation();
    var match = useMatch();
    var router = useRouter();
    var buildNext = useBuildNext();
    return useLatestCallback(function (navigate, opts) {
      return new Promise(function ($return, $error) {
        var _navigate$from, next, matchLoader;

        if (navigate === void 0) {
          navigate = location.current;
        }

        next = buildNext(_extends$1({}, navigate, {
          from: (_navigate$from = navigate.from) != null ? _navigate$from : {
            pathname: match.pathname
          }
        }));
        matchLoader = router.getMatchLoader(next);
        return Promise.resolve(matchLoader.load(opts)).then($return, $error);
      });
    });
  }
  function useParentMatches() {
    var router = useRouter();
    var match = useMatch();
    var matches = router.state.matches;
    return matches.slice(0, matches.findIndex(function (d) {
      return d.id === match.id;
    }) - 1);
  }
  function useMatches() {
    return React__namespace.useContext(MatchesContext);
  }
  function useMatch() {
    var _useMatches;

    return (_useMatches = useMatches()) == null ? void 0 : _useMatches[0];
  }
  function useNavigate() {
    var location = useLocation();
    var match = useMatch();
    var buildNext = useBuildNext();

    function navigate(_ref7) {
      var _fromCurrent;

      var search = _ref7.search,
          hash = _ref7.hash,
          replace = _ref7.replace,
          from = _ref7.from,
          to = _ref7.to,
          fromCurrent = _ref7.fromCurrent;
      fromCurrent = (_fromCurrent = fromCurrent) != null ? _fromCurrent : typeof to === 'undefined';
      var next = buildNext({
        to: to,
        search: search,
        hash: hash,
        from: fromCurrent ? location.current : from != null ? from : {
          pathname: match.pathname
        }
      });
      location.navigate(next, replace);
    }

    return useLatestCallback(navigate);
  }
  function Navigate(options) {
    var navigate = useNavigate();
    useLayoutEffect(function () {
      navigate(options);
    }, [navigate]);
    return null;
  }

  function useBuildNext() {
    var location = useLocation();
    var router = useRouter();

    var buildNext = function buildNext(opts) {
      var next = location.buildNext(router.basepath, opts);
      var matches = matchRoutes(router, next);

      var __searchFilters = matches.map(function (match) {
        var _match$route$searchFi;

        return (_match$route$searchFi = match.route.searchFilters) != null ? _match$route$searchFi : [];
      }).flat().filter(Boolean);

      return location.buildNext(router.basepath, _extends$1({}, opts, {
        __searchFilters: __searchFilters
      }));
    };

    return useLatestCallback(buildNext);
  }

  var Link = function Link(_ref8) {
    var _preload;

    var _ref8$to = _ref8.to,
        to = _ref8$to === void 0 ? '.' : _ref8$to,
        search = _ref8.search,
        hash = _ref8.hash,
        children = _ref8.children,
        target = _ref8.target,
        _ref8$style = _ref8.style,
        style = _ref8$style === void 0 ? {} : _ref8$style,
        replace = _ref8.replace,
        onClick = _ref8.onClick,
        onMouseEnter = _ref8.onMouseEnter,
        _ref8$className = _ref8.className,
        className = _ref8$className === void 0 ? '' : _ref8$className,
        _ref8$getActiveProps = _ref8.getActiveProps,
        getActiveProps = _ref8$getActiveProps === void 0 ? function () {
      return {};
    } : _ref8$getActiveProps,
        activeOptions = _ref8.activeOptions,
        preload = _ref8.preload,
        disabled = _ref8.disabled,
        _ref = _ref8._ref,
        rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);

    var loadRoute = useLoadRoute();
    var match = useMatch();
    var location = useLocation();
    var router = useRouter();
    var navigate = useNavigate();
    var buildNext = useBuildNext();
    preload = (_preload = preload) != null ? _preload : router.defaultLinkPreloadMaxAge; // If this `to` is a valid external URL, log a warning

    try {
      var url = new URL("" + to);
      "development" !== "production" ? warning(false, "<Link /> should not be used for external URLs like: " + url.href) : void 0;
    } catch (e) {}

    var next = buildNext({
      to: to,
      search: search,
      hash: hash,
      from: {
        pathname: match.pathname
      }
    }); // The click handler

    var handleClick = function handleClick(e) {
      if (onClick) onClick(e);

      if (!isCtrlEvent(e) && !e.defaultPrevented && (!target || target === '_self') && e.button === 0) {
        e.preventDefault(); // All is well? Navigate!

        navigate({
          to: to,
          search: search,
          hash: hash,
          replace: replace,
          from: {
            pathname: match.pathname
          }
        });
      }
    }; // The click handler


    var handleMouseEnter = function handleMouseEnter(e) {
      if (onMouseEnter) onMouseEnter(e);

      if (preload && preload > 0) {
        loadRoute({
          to: to,
          search: search,
          hash: hash
        }, {
          maxAge: preload
        });
      }
    }; // Compare path/hash for matches


    var pathIsEqual = location.current.pathname === next.pathname;
    var currentPathSplit = location.current.pathname.split('/');
    var nextPathSplit = next.pathname.split('/');
    var pathIsFuzzyEqual = nextPathSplit.every(function (d, i) {
      return d === currentPathSplit[i];
    });
    var hashIsEqual = location.current.hash === next.hash; // Combine the matches based on user options

    var pathTest = activeOptions != null && activeOptions.exact ? pathIsEqual : pathIsFuzzyEqual;
    var hashTest = activeOptions != null && activeOptions.includeHash ? hashIsEqual : true; // The final "active" test

    var isActive = pathTest && hashTest; // Get the active props

    var _ref9 = isActive ? getActiveProps() : {},
        _ref9$style = _ref9.style,
        activeStyle = _ref9$style === void 0 ? {} : _ref9$style,
        _ref9$className = _ref9.className,
        activeClassName = _ref9$className === void 0 ? '' : _ref9$className,
        activeRest = _objectWithoutPropertiesLoose(_ref9, _excluded3);

    return /*#__PURE__*/React__namespace.createElement("a", _extends$1({
      ref: _ref,
      href: disabled ? undefined : next.href,
      onClick: handleClick,
      onMouseEnter: handleMouseEnter,
      target: target,
      style: _extends$1({}, style, activeStyle),
      className: [className, activeClassName].filter(Boolean).join(' ') || undefined
    }, disabled ? {
      role: 'link',
      'aria-disabled': true
    } : undefined, rest, activeRest, {
      children: typeof children === 'function' ? children({
        isActive: isActive
      }) : children
    }));
  };
  function Outlet() {
    var _match$errorElement;

    var router = useRouter();

    var _useMatches2 = useMatches();
        _useMatches2[0];
        var matches = _useMatches2.slice(1);

    var match = matches[0];

    if (!match) {
      return null;
    }

    var errorElement = (_match$errorElement = match.errorElement) != null ? _match$errorElement : router.defaultErrorElement;

    var element = function () {
      var _match$pendingElement, _match$element;

      if (match.status === 'rejected') {
        if (errorElement) {
          return errorElement;
        }

        if (!router.useErrorBoundary) {
          {
            var preStyle = {
              whiteSpace: 'normal',
              display: 'inline-block',
              background: 'rgba(0,0,0,.1)',
              padding: '.1rem .2rem',
              margin: '.1rem',
              lineHeight: '1',
              borderRadius: '.25rem'
            };
            return /*#__PURE__*/React__namespace.createElement("div", {
              style: {
                lineHeight: '1.7'
              }
            }, /*#__PURE__*/React__namespace.createElement("strong", null, "The following error occured in the loader for you route at:", ' ', /*#__PURE__*/React__namespace.createElement("pre", {
              style: preStyle
            }, match.pathname)), ".", /*#__PURE__*/React__namespace.createElement("br", null), /*#__PURE__*/React__namespace.createElement("pre", {
              style: _extends$1({}, preStyle, {
                display: 'block',
                padding: '.5rem',
                borderRadius: '.5rem'
              })
            }, match.error.toString()), /*#__PURE__*/React__namespace.createElement("br", null), "Your users won't see this message in production, but they will see", ' ', /*#__PURE__*/React__namespace.createElement("strong", null, "\"An unknown error occured!\""), ", which is at least better than breaking your entire app. \uD83D\uDE0A For a better UX, please specify an ", /*#__PURE__*/React__namespace.createElement("pre", {
              style: preStyle
            }, "errorElement"), " for all of your routes that contain asynchronous behavior, or at least provide your own", /*#__PURE__*/React__namespace.createElement("pre", {
              style: preStyle
            }, "ErrorBoundary"), " wrapper around your renders to both the elements rendered by", ' ', /*#__PURE__*/React__namespace.createElement("pre", {
              style: preStyle
            }, 'useRoutes(routes, { useErrorBoundary: true })'), ' ', "and ", /*#__PURE__*/React__namespace.createElement("pre", {
              style: preStyle
            }, '<Router useErrorBoundary />'), ".", ' ', /*#__PURE__*/React__namespace.createElement("br", null), /*#__PURE__*/React__namespace.createElement("br", null));
          }
        }

        throw match.error;
      }

      var pendingElement = (_match$pendingElement = match.pendingElement) != null ? _match$pendingElement : router.defaultPendingElement;

      if (match.status === 'pending') {
        if (match.route.pendingMs || pendingElement) {
          return pendingElement != null ? pendingElement : null;
        }
      }

      var matchElement = (_match$element = match.element) != null ? _match$element : router.defaultElement;
      return matchElement ? /*#__PURE__*/React__namespace.createElement(React__namespace.Fragment, null, matchElement) : /*#__PURE__*/React__namespace.createElement(Outlet, null);
    }();

    return /*#__PURE__*/React__namespace.createElement(MatchesProvider, {
      value: matches
    }, element);
  }
  function useResolvePath() {
    var router = useRouter();
    var match = useMatch();
    return useLatestCallback(function (path) {
      return resolvePath(router.basepath, match.pathname, cleanPath(path));
    });
  }
  function useSearch() {
    var location = useLocation();
    return location.current.search;
  }
  function matchRoute(currentLocation, matchLocation) {
    var pathParams = matchByPath(currentLocation, matchLocation);
    var searchMatched = matchBySearch(currentLocation, matchLocation);

    if (matchLocation.to && !pathParams) {
      return;
    }

    if (matchLocation.search && !searchMatched) {
      return;
    }

    return pathParams != null ? pathParams : {};
  }
  function useMatchRoute() {
    var router = useRouter();
    var resolvePath = useResolvePath();
    return useLatestCallback(function (_ref10) {
      var pending = _ref10.pending,
          matchLocation = _objectWithoutPropertiesLoose(_ref10, _excluded4);

      matchLocation = _extends$1({}, matchLocation, {
        to: matchLocation.to ? resolvePath("" + matchLocation.to) : undefined
      });

      if (pending) {
        var _router$pending;

        if (!((_router$pending = router.pending) != null && _router$pending.location)) {
          return undefined;
        }

        return matchRoute(router.pending.location, matchLocation);
      }

      return matchRoute(router.state.location, matchLocation);
    });
  }
  function MatchRoute(_ref11) {
    var children = _ref11.children,
        rest = _objectWithoutPropertiesLoose(_ref11, _excluded5);

    var matchRoute = useMatchRoute();
    var match = matchRoute(rest);

    if (typeof children === 'function') {
      return children(match);
    }

    return match ? children : null;
  }
  function usePrompt(message, when) {
    var location = useLocation();
    React__namespace.useEffect(function () {
      if (!when) return;
      var unblock = location.history.block(function (transition) {
        if (window.confirm(message)) {
          unblock();
          transition.retry();
        } else {
          location.current.pathname = window.location.pathname;
        }
      });
      return unblock;
    }, [when, location, message]);
  }
  function Prompt(_ref12) {
    var message = _ref12.message,
        when = _ref12.when,
        children = _ref12.children;
    usePrompt(message, when != null ? when : true);
    return children != null ? children : null;
  }

  function warning(cond, message) {
    if (!cond) {
      if (typeof console !== 'undefined') console.warn(message);

      try {
        throw new Error(message);
      } catch (_unused) {}
    }
  }

  function isFunction(d) {
    return typeof d === 'function';
  }

  function functionalUpdate(updater, previous) {
    if (isFunction(updater)) {
      return updater(previous);
    }

    return updater;
  }

  function joinPaths(paths) {
    return cleanPath(paths.filter(Boolean).join('/'));
  }

  function cleanPath(path) {
    // remove double slashes
    return ("" + path).replace(/\/{2,}/g, '/');
  }
  function matchByPath(currentLocation, matchLocation) {
    var _matchLocation$to;

    var baseSegments = parsePathname(currentLocation.pathname);
    var routeSegments = parsePathname("" + ((_matchLocation$to = matchLocation.to) != null ? _matchLocation$to : '*')); // console.log(baseSegments, routeSegments)

    var params = {};

    var isMatch = function () {
      for (var i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {
        var baseSegment = baseSegments[i];
        var routeSegment = routeSegments[i];
        var isLastRouteSegment = i === routeSegments.length - 1;
        var isLastBaseSegment = i === baseSegments.length - 1;

        if (routeSegment) {
          if (routeSegment.type === 'wildcard') {
            if (baseSegment != null && baseSegment.value) {
              params['*'] = joinPaths(baseSegments.slice(i).map(function (d) {
                return d.value;
              }));
              return true;
            }

            return false;
          }

          if (routeSegment.type === 'pathname') {
            if (routeSegment.value === '/' && !(baseSegment != null && baseSegment.value)) {
              return true;
            }

            if (baseSegment) {
              if (routeSegment.value !== baseSegment.value) {
                return false;
              }
            }
          }

          if (!baseSegment) {
            return false;
          }

          if (routeSegment.type === 'param') {
            params[routeSegment.value.substring(1)] = baseSegment.value;
          }
        }

        if (isLastRouteSegment && !isLastBaseSegment) {
          return !!matchLocation.fuzzy;
        }
      }

      return true;
    }();

    return isMatch ? params : undefined;
  }

  function matchBySearch(currentLocation, matchLocation) {
    return !!(matchLocation.search && matchLocation.search(currentLocation.search));
  }

  function parsePathname(pathname) {
    if (!pathname) {
      return [];
    }

    pathname = cleanPath(pathname);
    var segments = [];

    if (pathname.slice(0, 1) === '/') {
      pathname = pathname.substring(1);
      segments.push({
        type: 'pathname',
        value: '/'
      });
    }

    if (!pathname) {
      return segments;
    } // Remove empty segments and '.' segments


    var split = pathname.split('/').filter(Boolean);
    segments.push.apply(segments, split.map(function (part) {
      if (part.startsWith('*')) {
        return {
          type: 'wildcard',
          value: part
        };
      }

      if (part.charAt(0) === ':') {
        return {
          type: 'param',
          value: part
        };
      }

      return {
        type: 'pathname',
        value: part
      };
    }));

    if (pathname.slice(-1) === '/') {
      pathname = pathname.substring(1);
      segments.push({
        type: 'pathname',
        value: '/'
      });
    }

    return segments;
  }

  function resolvePath(basepath, base, to) {
    base = base.replace(new RegExp("^" + basepath), '/');
    to = to.replace(new RegExp("^" + basepath), '/');
    var baseSegments = parsePathname(base);
    var toSegments = parsePathname(to);
    toSegments.forEach(function (toSegment, index) {
      if (toSegment.value === '/') {
        if (!index) {
          baseSegments = [toSegment];
        }
      } else if (toSegment.value === '..') {
        baseSegments.pop();
      } else if (toSegment.value === '.') {
        return;
      } else {
        baseSegments.push(toSegment);
      }
    });
    var joined = joinPaths([basepath].concat(baseSegments.map(function (d) {
      return d.value;
    })));
    return cleanPath(joined);
  }

  function isCtrlEvent(e) {
    return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
  }

  function useLatestCallback(cb) {
    var stableFnRef = React__namespace.useRef();
    var cbRef = React__namespace.useRef(cb);
    cbRef.current = cb;

    if (!stableFnRef.current) {
      stableFnRef.current = function () {
        return cbRef.current.apply(cbRef, arguments);
      };
    }

    return stableFnRef.current;
  }

  function useGetIsMounted() {
    var ref = React__namespace.useRef(false);
    React__namespace.useEffect(function () {
      ref.current = true;
      return function () {
        ref.current = false;
      };
    });
    return function () {
      return ref.current;
    };
  }
  /**
   * This function returns `a` if `b` is deeply equal.
   * If not, it will replace any deeply equal children of `b` with those of `a`.
   * This can be used for structural sharing between JSON values for example.
   */


  function replaceEqualDeep(prev, next) {
    if (prev === next) {
      return prev;
    }

    var array = Array.isArray(prev) && Array.isArray(next);

    if (array || isPlainObject(prev) && isPlainObject(next)) {
      var aSize = array ? prev.length : Object.keys(prev).length;
      var bItems = array ? next : Object.keys(next);
      var bSize = bItems.length;
      var copy = array ? [] : {};
      var equalItems = 0;

      for (var i = 0; i < bSize; i++) {
        var key = array ? i : bItems[i];
        copy[key] = replaceEqualDeep(prev[key], next[key]);

        if (copy[key] === prev[key]) {
          equalItems++;
        }
      }

      return aSize === bSize && equalItems === aSize ? prev : copy;
    }

    return next;
  } // Copied from: https://github.com/jonschlinkert/is-plain-object


  function isPlainObject(o) {
    if (!hasObjectPrototype(o)) {
      return false;
    } // If has modified constructor


    var ctor = o.constructor;

    if (typeof ctor === 'undefined') {
      return true;
    } // If has modified prototype


    var prot = ctor.prototype;

    if (!hasObjectPrototype(prot)) {
      return false;
    } // If constructor does not have an Object-specific method


    if (!prot.hasOwnProperty('isPrototypeOf')) {
      return false;
    } // Most likely a plain Object


    return true;
  }

  function hasObjectPrototype(o) {
    return Object.prototype.toString.call(o) === '[object Object]';
  }

  function defaultStringifySearch(search) {
    search = _extends$1({}, search);

    if (search) {
      Object.keys(search).forEach(function (key) {
        var val = search[key];

        if (typeof val === 'undefined' || val === undefined) {
          delete search[key];
        } else if (val && typeof val === 'object' && val !== null) {
          try {
            search[key] = JSON.stringify(val);
          } catch (err) {// silent
          }
        }
      });
    }

    var searchStr = new URLSearchParams(search).toString();
    return searchStr ? "?" + searchStr : '';
  }
  function defaultParseSearch(searchStr) {
    if (searchStr.substring(0, 1) === '?') {
      searchStr = searchStr.substring(1);
    }

    var query = Object.fromEntries(new URLSearchParams(searchStr).entries()); // Try to parse query params

    for (var key in query) {
      var value = query[key];

      try {
        query[key] = JSON.parse(value);
      } catch (err) {//
      }
    }

    return query;
  }

  exports.Link = Link;
  exports.MatchRoute = MatchRoute;
  exports.MatchesProvider = MatchesProvider;
  exports.Navigate = Navigate;
  exports.Outlet = Outlet;
  exports.Prompt = Prompt;
  exports.ReactLocation = ReactLocation;
  exports.RouteMatch = RouteMatch;
  exports.Router = Router;
  exports.RouterInstance = RouterInstance;
  exports.cleanPath = cleanPath;
  exports.createBrowserHistory = createBrowserHistory;
  exports.createHashHistory = createHashHistory;
  exports.createMemoryHistory = createMemoryHistory;
  exports.defaultParseSearch = defaultParseSearch;
  exports.defaultStringifySearch = defaultStringifySearch;
  exports.functionalUpdate = functionalUpdate;
  exports.matchByPath = matchByPath;
  exports.matchRoute = matchRoute;
  exports.matchRoutes = matchRoutes;
  exports.parsePathname = parsePathname;
  exports.useLoadRoute = useLoadRoute;
  exports.useLocation = useLocation;
  exports.useMatch = useMatch;
  exports.useMatchRoute = useMatchRoute;
  exports.useMatches = useMatches;
  exports.useNavigate = useNavigate;
  exports.useParentMatches = useParentMatches;
  exports.usePrompt = usePrompt;
  exports.useResolvePath = useResolvePath;
  exports.useRouter = useRouter;
  exports.useSearch = useSearch;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=react-location.development.js.map
