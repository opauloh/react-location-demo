{"version":3,"file":"react-location.production.min.js","sources":["../../../node_modules/@babel/runtime/helpers/esm/extends.js","../src/index.tsx"],"sourcesContent":["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}","import * as React from 'react'\n\nimport {\n  createHashHistory,\n  createBrowserHistory,\n  createMemoryHistory,\n  BrowserHistory,\n  MemoryHistory,\n  History,\n  HashHistory,\n} from 'history'\n\nexport { createHashHistory, createBrowserHistory, createMemoryHistory }\n\n// Types\n\ntype Timeout = ReturnType<typeof setTimeout>\n\ntype Maybe<T, TUnknown> = T extends {} ? T : TUnknown\n\nexport type DefaultGenerics = {\n  LoaderData: LoaderData<unknown>\n  Params: Params<string>\n  Search: Search<unknown>\n  RouteMeta: RouteMeta<unknown>\n}\n\nexport type PartialGenerics = Partial<DefaultGenerics>\n\nexport type MakeGenerics<TGenerics extends PartialGenerics> = TGenerics\n\nexport type Search<T> = Record<string, T>\nexport type Params<T> = Record<string, T>\nexport type LoaderData<T> = Record<string, T>\nexport type RouteMeta<T> = Record<string, T>\n\nexport type UseGeneric<\n  TGenerics extends PartialGenerics,\n  TGeneric extends keyof PartialGenerics,\n> = TGeneric extends 'LoaderData' | 'Search'\n  ? Partial<Maybe<TGenerics[TGeneric], DefaultGenerics[TGeneric]>>\n  : Maybe<TGenerics[TGeneric], DefaultGenerics[TGeneric]>\n\nexport type ReactLocationOptions = {\n  // The history object to be used internally by react-location\n  // A history will be created automatically if not provided.\n  history?: BrowserHistory | MemoryHistory | HashHistory\n  stringifySearch?: SearchSerializer\n  parseSearch?: SearchParser\n}\n\ntype SearchSerializer = (searchObj: Record<string, any>) => string\ntype SearchParser = (searchStr: string) => Record<string, any>\n\nexport type Updater<TResult> = TResult | ((prev?: TResult) => TResult)\n\nexport type Location<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  href: string\n  pathname: string\n  search: UseGeneric<TGenerics, 'Search'>\n  searchStr: string\n  hash: string\n  key?: string\n  // nextAction?: 'push' | 'replace'\n}\n\nexport type Route<TGenerics extends PartialGenerics = DefaultGenerics> =\n  // Route Loaders (see below) can be inline on the route, or resolved async\n  // via the `import` property\n  RouteLoaders<TGenerics> & {\n    // The path to match (relative to the nearest parent `Route` component or root basepath)\n    path?: string\n    // Either (1) an object that will be used to shallowly match the current location's search or (2) A function that receives the current search params and can return truthy if they are matched.\n    search?: SearchPredicate<UseGeneric<TGenerics, 'Search'>>\n    // The duration to wait during `loader` execution before showing the `pendingElement`\n    pendingMs?: number\n    // _If the `pendingElement` is shown_, the minimum duration for which it will be visible.\n    pendingMinMs?: number\n    // Search filters can be used to rewrite, persist, default and manipulate search params for link that\n    // point to their routes or child routes. See the \"basic\" example to see them in action.\n    searchFilters?: SearchFilter<TGenerics>[]\n    // An array of child routes\n    children?: Route<TGenerics>[]\n  } & {\n    // If `import` is defined, this route can resolve its elements and loaders in a single asynchronous call\n    // This is particularly useful for code-splitting or module federation\n    import?: (opts: {\n      params: UseGeneric<TGenerics, 'Params'>\n      search: UseGeneric<TGenerics, 'Search'>\n    }) => Promise<RouteLoaders<TGenerics>>\n  }\n\nexport type RouteLoaders<TGenerics> = {\n  // The content to be rendered when the route is matched. If no element is provided, defaults to `<Outlet />`\n  element?: SyncOrAsyncElement<TGenerics>\n  // The content to be rendered when `loader` encounters an error\n  errorElement?: SyncOrAsyncElement<TGenerics>\n  // The content to be rendered when the duration of `loader` execution surpasses the `pendingMs` duration\n  pendingElement?: SyncOrAsyncElement<TGenerics>\n  // An asynchronous function responsible for preparing or fetching data for the route before it is rendered\n  loader?: LoaderFn<TGenerics>\n  // An integer of milliseconds representing how long data should be cached for the route\n  loaderMaxAge?: number\n  // Similar to React's useEffect hook, this function is called\n  // when moving from an inactive state to an active one. Likewise, when moving from\n  // an active to an inactive state, the return function (if provided) is called.\n  onMatch?: (\n    match: RouteMatch<TGenerics>,\n  ) => void | undefined | ((match: RouteMatch<TGenerics>) => void)\n  // This function is called when the route remains active from one transition to the next.\n  onTransition?: (match: RouteMatch<TGenerics>) => void\n  // An object of whatever you want! This object is accessible anywhere matches are.\n  meta?: UseGeneric<TGenerics, 'RouteMeta'>\n}\n\nexport type SearchFilter<TGenerics> = (\n  prev: UseGeneric<TGenerics, 'Search'>,\n  next: UseGeneric<TGenerics, 'Search'>,\n) => UseGeneric<TGenerics, 'Search'>\n\nexport type MatchLocation<TGenerics extends PartialGenerics = DefaultGenerics> =\n  {\n    to?: string | number | null\n    search?: SearchPredicate<UseGeneric<TGenerics, 'Search'>>\n    fuzzy?: boolean\n  }\n\nexport type SearchPredicate<TSearch> = (search: TSearch) => any\n\nexport type SyncOrAsyncElement<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = React.ReactNode | AsyncElement<TGenerics>\n\nexport type AsyncElement<TGenerics extends PartialGenerics = DefaultGenerics> =\n  (opts: {\n    params: UseGeneric<TGenerics, 'Params'>\n  }) => Promise<React.ReactNode>\n\nexport type UnloadedMatch<TGenerics extends PartialGenerics = DefaultGenerics> =\n  {\n    id: string\n    route: Route<TGenerics>\n    routeIndex: number\n    pathname: string\n    params: UseGeneric<TGenerics, 'Params'>\n    search: UseGeneric<TGenerics, 'Search'>\n  }\n\nexport type LoaderFn<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  routeMatch: RouteMatch<TGenerics>,\n  opts: LoaderFnOptions<TGenerics>,\n) => PromiseLike<UseGeneric<TGenerics, 'LoaderData'>>\n\nexport type LoaderFnOptions<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = {\n  parentMatch?: RouteMatch<TGenerics>\n  dispatch: (event: LoaderDispatchEvent<TGenerics>) => void\n}\n\ntype PromiseLike<T> = Promise<T> | T\n\nexport type ListenerFn = () => void\n\nexport type Segment = {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport type RouterProps<TGenerics extends PartialGenerics = DefaultGenerics> = {\n  // Children will default to `<Outlet />` if not provided\n  children?: React.ReactNode\n} & RouterOptions<TGenerics>\n\nexport type RouterOptions<TGenerics> = {\n  // An array of route objects to match\n  location: ReactLocation<TGenerics>\n  routes: Route<TGenerics>[]\n  basepath?: string\n  filterRoutes?: FilterRoutesFn\n  defaultLinkPreloadMaxAge?: number\n  defaultLoaderMaxAge?: number\n  useErrorBoundary?: boolean\n  defaultElement?: SyncOrAsyncElement<TGenerics>\n  defaultErrorElement?: SyncOrAsyncElement<TGenerics>\n  defaultPendingElement?: SyncOrAsyncElement<TGenerics>\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  // An array of route match objects that have been both _matched_ and _loaded_. See the [SRR](#ssr) section for more details\n  initialMatches?: RouteMatch<TGenerics>[]\n}\n\nexport type BuildNextOptions<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = {\n  to?: string | number | null\n  search?: true | Updater<UseGeneric<TGenerics, 'Search'>>\n  hash?: Updater<string>\n  from?: Partial<Location<TGenerics>>\n  key?: string\n  __searchFilters?: SearchFilter<TGenerics>[]\n}\n\nexport type NavigateOptions<TGenerics> = BuildNextOptions<TGenerics> & {\n  replace?: boolean\n  fromCurrent?: boolean\n}\n\nexport type PromptProps = {\n  message: string\n  when?: boolean | any\n  children?: React.ReactNode\n}\n\nexport type LinkProps<TGenerics extends PartialGenerics = DefaultGenerics> =\n  Omit<React.AnchorHTMLAttributes<HTMLAnchorElement>, 'href' | 'children'> & {\n    // The absolute or relative destination pathname\n    to?: string | number | null\n    // The new search object or a function to update it\n    search?: true | Updater<UseGeneric<TGenerics, 'Search'>>\n    // The new has string or a function to update it\n    hash?: Updater<string>\n    // Whether to replace the current history stack instead of pushing a new one\n    replace?: boolean\n    // A function that is passed the [Location API](#location-api) and returns additional props for the `active` state of this link. These props override other props passed to the link (`style`'s are merged, `className`'s are concatenated)\n    getActiveProps?: () => Record<string, any>\n    // Defaults to `{ exact: false, includeHash: false }`\n    activeOptions?: ActiveOptions\n    // If set, will preload the linked route on hover and cache it for this many milliseconds in hopes that the user will eventually navigate there.\n    preload?: number\n    // If true, will render the link without the href attribute\n    disabled?: boolean\n    // A custom ref prop because of this: https://stackoverflow.com/questions/58469229/react-with-typescript-generics-while-using-react-forwardref/58473012\n    _ref?: React.Ref<HTMLAnchorElement>\n    // If a function is pass as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n    children?:\n      | React.ReactNode\n      | ((state: { isActive: boolean }) => React.ReactNode)\n  }\n\ntype ActiveOptions = {\n  exact?: boolean\n  includeHash?: boolean\n}\n\nexport type LinkPropsType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  LinkProps<TGenerics>\n\nexport type LoaderDispatchEvent<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> =\n  | {\n      type: 'maxAge'\n      maxAge: number\n    }\n  | {\n      type: 'loading'\n    }\n  | {\n      type: 'resolve'\n      data: UseGeneric<TGenerics, 'LoaderData'>\n    }\n  | {\n      type: 'reject'\n      error: unknown\n    }\n\nexport type LoadRouteFn<TGenerics> = (\n  next: Location<TGenerics>,\n) => MatchLoader<TGenerics>\n\nexport type TransitionState<TGenerics> = {\n  status: 'pending' | 'ready'\n  location: Location<TGenerics>\n  matches: RouteMatch<TGenerics>[]\n}\n\nexport type FilterRoutesFn = <\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  routes: Route<TGenerics>[],\n) => Route<TGenerics>[]\n\nexport type RouterPropsType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = RouterProps<TGenerics>\n\nexport type RouterType<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  props: RouterProps<TGenerics>,\n) => JSX.Element\n\ntype Listener<TPayload> = (payload: TPayload) => void\n\n// Source\n\nconst LocationContext = React.createContext<ReactLocation<any>>(null!)\nconst MatchesContext = React.createContext<RouteMatch<any>[]>(null!)\nconst routerContext = React.createContext<{ router: RouterInstance<any> }>(\n  null!,\n)\n\n// Detect if we're in the DOM\nconst isDOM = Boolean(\n  typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement,\n)\n\nconst useLayoutEffect = isDOM ? React.useLayoutEffect : React.useEffect\n\n// This is the default history object if none is defined\nconst createDefaultHistory = () =>\n  isDOM ? createBrowserHistory() : createMemoryHistory()\n\nclass Subscribable<TPayload = void> {\n  listeners: Listener<TPayload>[]\n\n  constructor() {\n    this.listeners = []\n  }\n\n  subscribe(listener: Listener<TPayload>): () => void {\n    this.listeners.push(listener as Listener<TPayload>)\n\n    return () => {\n      this.listeners = this.listeners.filter((x) => x !== listener)\n    }\n  }\n\n  notify(payload: TPayload): void {\n    this.listeners.forEach((listener) => listener(payload))\n  }\n}\n\nexport class ReactLocation<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> extends Subscribable {\n  history: BrowserHistory | MemoryHistory\n  stringifySearch: SearchSerializer\n  parseSearch: SearchParser\n\n  current: Location<TGenerics>\n  destroy: () => void\n  navigateTimeout?: Timeout\n  nextAction?: 'push' | 'replace'\n\n  //\n\n  isTransitioning: boolean = false\n\n  constructor(options?: ReactLocationOptions) {\n    super()\n    this.history = options?.history || createDefaultHistory()\n    this.stringifySearch = options?.stringifySearch ?? defaultStringifySearch\n    this.parseSearch = options?.parseSearch ?? defaultParseSearch\n\n    this.current = this.parseLocation(this.history.location)\n\n    this.destroy = this.history.listen((event) => {\n      this.current = this.parseLocation(event.location, this.current)\n      this.notify()\n    })\n  }\n\n  buildNext(\n    basepath: string = '/',\n    dest: BuildNextOptions<TGenerics> = {},\n  ): Location<TGenerics> {\n    const from = {\n      ...this.current,\n      ...dest.from,\n    }\n\n    const pathname = resolvePath(basepath, from.pathname, `${dest.to ?? '.'}`)\n\n    const updatedSearch =\n      (dest.search === true\n        ? from.search\n        : functionalUpdate(dest.search, from.search)) ?? {}\n\n    const filteredSearch = dest.__searchFilters?.length\n      ? dest.__searchFilters.reduce(\n          (prev, next) => next(prev, updatedSearch),\n          from.search,\n        )\n      : updatedSearch\n\n    const search = replaceEqualDeep(from.search, filteredSearch)\n\n    const searchStr = this.stringifySearch(search)\n    let hash = functionalUpdate(dest.hash, from.hash)\n    hash = hash ? `#${hash}` : ''\n\n    return {\n      pathname,\n      search,\n      searchStr,\n      hash,\n      href: `${pathname}${searchStr}${hash}`,\n      key: dest.key,\n    }\n  }\n\n  navigate(next: Location<TGenerics>, replace?: boolean): void {\n    this.current = next\n\n    if (this.navigateTimeout) clearTimeout(this.navigateTimeout)\n\n    let nextAction: 'push' | 'replace' = 'replace'\n\n    if (!this.nextAction) {\n      nextAction = replace ? 'replace' : 'push'\n    }\n\n    if (!replace) {\n      nextAction = 'push'\n    }\n\n    this.nextAction = nextAction\n\n    this.navigateTimeout = setTimeout(() => {\n      let nextAction = this.nextAction\n      delete this.nextAction\n\n      const isSameUrl =\n        this.parseLocation(this.history.location).href === this.current.href\n\n      if (isSameUrl && !this.current.key) {\n        nextAction = 'replace'\n      }\n\n      if (nextAction === 'replace') {\n        return this.history.replace({\n          pathname: this.current.pathname,\n          hash: this.current.hash,\n          search: this.current.searchStr,\n        })\n      }\n\n      return this.history.push({\n        pathname: this.current.pathname,\n        hash: this.current.hash,\n        search: this.current.searchStr,\n      })\n    }, 16)\n  }\n\n  parseLocation(\n    location: History['location'],\n    previousLocation?: Location<TGenerics>,\n  ): Location<TGenerics> {\n    const parsedSearch = this.parseSearch(location.search)\n\n    return {\n      pathname: location.pathname,\n      searchStr: location.search,\n      search: replaceEqualDeep(previousLocation?.search, parsedSearch),\n      hash: location.hash.split('#').reverse()[0] ?? '',\n      href: `${location.pathname}${location.search}${location.hash}`,\n      key: location.key,\n    }\n  }\n}\n\nexport type MatchesProviderProps<TGenerics> = {\n  value: RouteMatch<TGenerics>[]\n  children: React.ReactNode\n}\n\nexport function MatchesProvider<TGenerics>(\n  props: MatchesProviderProps<TGenerics>,\n) {\n  return <MatchesContext.Provider {...props} />\n}\n\nexport function Router<TGenerics extends PartialGenerics = DefaultGenerics>({\n  children,\n  location,\n  ...rest\n}: RouterProps<TGenerics>) {\n  const routerRef = React.useRef<RouterInstance<TGenerics>>(null!)\n  if (!routerRef.current) {\n    routerRef.current = new RouterInstance<TGenerics>({ ...rest, location })\n  }\n  const router = routerRef.current\n\n  const [nonce, rerender] = React.useReducer(() => ({}), {})\n\n  useLayoutEffect(() => {\n    return router.subscribe(rerender)\n  }, [])\n\n  useLayoutEffect(() => {\n    return router.updateLocation(location.current).unsubscribe\n  }, [location.current.key])\n\n  const routerValue = React.useMemo(\n    () => ({\n      router,\n    }),\n    [nonce],\n  )\n\n  return (\n    <LocationContext.Provider value={location}>\n      <routerContext.Provider value={routerValue}>\n        <MatchesProvider value={[router.rootMatch, ...router.state.matches]}>\n          {children}\n        </MatchesProvider>\n      </routerContext.Provider>\n    </LocationContext.Provider>\n  )\n}\n\ntype RouterInstanceState<TGenerics> = {\n  state: TransitionState<TGenerics>\n  pending?: TransitionState<TGenerics>\n}\n\nexport class RouterInstance<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> extends Subscribable {\n  basepath: string\n  rootMatch: RouteMatch<TGenerics>\n  state: TransitionState<TGenerics>\n  pending?: TransitionState<TGenerics>\n  routes!: Route<TGenerics>[]\n  filterRoutes?: FilterRoutesFn\n  defaultLinkPreloadMaxAge?: number\n  defaultLoaderMaxAge?: number\n  useErrorBoundary?: boolean\n  defaultElement: SyncOrAsyncElement<TGenerics>\n  defaultErrorElement: SyncOrAsyncElement<TGenerics>\n  defaultPendingElement: SyncOrAsyncElement<TGenerics>\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n\n  constructor(\n    opts: { location: ReactLocation<TGenerics> } & RouterOptions<TGenerics>,\n  ) {\n    super()\n    Object.assign(this, opts)\n\n    this.basepath = cleanPath(`/${opts.basepath ?? ''}`)\n    this.rootMatch = {\n      id: 'root',\n      params: {} as any,\n      search: {} as any,\n      routeIndex: 0,\n      pathname: this.basepath,\n      route: null!,\n      data: {},\n      isLoading: false,\n      status: 'resolved',\n    }\n\n    this.state = {\n      status: 'ready',\n      location: opts.location.current,\n      matches: opts.initialMatches ?? [],\n    }\n\n    opts.location.subscribe(() => this.notify())\n  }\n\n  setState = (\n    updater: (\n      old: RouterInstanceState<TGenerics>,\n    ) => RouterInstanceState<TGenerics>,\n  ) => {\n    const newState = updater({ state: this.state, pending: this.pending })\n    this.state = newState.state\n    this.pending = newState.pending\n    this.cleanMatchCache()\n    this.notify()\n  }\n\n  matchCache: Record<string, RouteMatch<TGenerics>> = {}\n\n  getMatchLoader = (next: Location<TGenerics>) => {\n    return new MatchLoader(this, next)\n  }\n\n  cleanMatchCache = () => {\n    const activeMatchIds = [\n      ...(this?.state.matches ?? []),\n      ...(this?.pending?.matches ?? []),\n    ].map((d) => d.id)\n\n    Object.values(this.matchCache).forEach((match) => {\n      if (!match.updatedAt) {\n        return\n      }\n\n      if (activeMatchIds.includes(match.id)) {\n        return\n      }\n\n      const age = Date.now() - (match.updatedAt ?? 0)\n\n      if (!match.maxAge || age > match.maxAge) {\n        delete this.matchCache[match.id]\n      }\n    })\n  }\n\n  updateLocation = (next: Location<TGenerics>) => {\n    let unsubscribe: () => void\n\n    const promise = new Promise<void>((resolve) => {\n      const matchLoader = this.getMatchLoader(next)\n\n      this.state.matches?.forEach((match) => {\n        match.used = true\n      })\n\n      this.setState((old) => {\n        return {\n          ...old,\n          pending: {\n            status: 'pending',\n            location: matchLoader.location,\n            matches: matchLoader.matches,\n          },\n        }\n      })\n\n      unsubscribe = matchLoader.subscribe(() => {\n        const currentMatches = this.state.matches\n\n        currentMatches\n          .filter((d) => {\n            return !matchLoader.matches.find((dd) => dd.id === d.id)\n          })\n          .forEach((d) => {\n            d.onExit?.(d)\n          })\n\n        currentMatches\n          .filter((d) => {\n            return matchLoader.matches.find((dd) => dd.id === d.id)\n          })\n          .forEach((d) => {\n            d.route.onTransition?.(d)\n          })\n\n        matchLoader.matches\n          .filter((d) => {\n            return !currentMatches.find((dd) => dd.id === d.id)\n          })\n          .forEach((d) => {\n            d.onExit = d.route.onMatch?.(d)\n          })\n\n        this.setState((old) => {\n          return {\n            ...old,\n            state: {\n              status: 'ready',\n              location: matchLoader.location,\n              matches: matchLoader.matches,\n            },\n            pending: undefined,\n          }\n        })\n\n        resolve()\n      })\n\n      matchLoader.loadData()\n      matchLoader.startPending()\n    })\n\n    return {\n      promise,\n      unsubscribe: unsubscribe!,\n    }\n  }\n}\n\nexport type UseLocationType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => ReactLocation<TGenerics>\n\nexport function useLocation<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): ReactLocation<TGenerics> {\n  const getIsMounted = useGetIsMounted()\n  const [, rerender] = React.useReducer((d) => d + 1, 0)\n  const instance = React.useContext(LocationContext) as ReactLocation<TGenerics>\n  warning(!!instance, 'useLocation must be used within a <ReactLocation />')\n\n  useLayoutEffect(() => {\n    return instance.subscribe(() => {\n      // Rerender all subscribers in a microtask\n      Promise.resolve().then(() => {\n        setTimeout(function renderAllLocationSubscribers() {\n          if (getIsMounted()) {\n            rerender()\n          }\n        }, 0)\n      })\n    })\n  }, [instance])\n\n  return instance\n}\n\nexport class RouteMatch<TGenerics extends PartialGenerics = DefaultGenerics> {\n  id!: string\n  route!: Route<TGenerics>\n  routeIndex!: number\n  pathname!: string\n  params!: UseGeneric<TGenerics, 'Params'>\n  search!: UseGeneric<TGenerics, 'Search'>\n  updatedAt?: number\n  element?: React.ReactNode\n  errorElement?: React.ReactNode\n  pendingElement?: React.ReactNode\n  error?: unknown\n  loaderPromise?: Promise<UseGeneric<TGenerics, 'LoaderData'>>\n  used?: boolean\n  maxAge?: number\n  matchLoader?: MatchLoader<TGenerics>\n  pendingTimeout?: Timeout\n  pendingMinPromise?: Promise<void>\n  onExit?: void | ((match: RouteMatch<TGenerics>) => void)\n\n  constructor(unloadedMatch: UnloadedMatch<TGenerics>) {\n    Object.assign(this, unloadedMatch)\n  }\n\n  status: 'pending' | 'resolved' | 'rejected' = 'pending'\n  data: UseGeneric<TGenerics, 'LoaderData'> = {}\n  isLoading: boolean = false\n\n  private notify? = (isSoft?: boolean) => {\n    this.matchLoader?.notify(isSoft)\n  }\n\n  assignMatchLoader? = (matchLoader: MatchLoader<TGenerics>) => {\n    this.matchLoader = matchLoader\n  }\n\n  startPending? = () => {\n    if (this.pendingTimeout) {\n      clearTimeout(this.pendingTimeout)\n    }\n\n    if (this.route.pendingMs) {\n      this.pendingTimeout = setTimeout(() => {\n        this.notify?.()\n        if (typeof this.route.pendingMinMs !== 'undefined') {\n          this.pendingMinPromise = new Promise((r) =>\n            setTimeout(r, this.route.pendingMinMs),\n          )\n        }\n      }, this.route.pendingMs)\n    }\n  }\n\n  load? = (opts: {\n    maxAge?: number\n    parentMatch?: RouteMatch<TGenerics>\n    router: RouterInstance<TGenerics>\n  }) => {\n    this.maxAge =\n      opts.maxAge ?? this.route.loaderMaxAge ?? opts.router.defaultLoaderMaxAge\n\n    if (this.loaderPromise) {\n      return\n    }\n\n    const importer = this.route.import\n\n    // First, run any importers\n    this.loaderPromise = (\n      !importer\n        ? Promise.resolve()\n        : importer({ params: this.params, search: this.search }).then(\n            (imported) => {\n              this.route = {\n                ...this.route,\n                ...imported,\n              }\n            },\n          )\n    )\n      // then run all element and data loaders in parallel\n      .then(() => {\n        const elementPromises: Promise<void>[] = []\n\n        // For each element type, potentially load it asynchronously\n        const elementTypes = [\n          'element',\n          'errorElement',\n          'pendingElement',\n        ] as const\n\n        elementTypes.forEach((type) => {\n          const routeElement = this.route[type]\n\n          if (this[type]) {\n            return\n          }\n\n          if (typeof routeElement === 'function') {\n            elementPromises.push(\n              (routeElement as AsyncElement)(this).then((res) => {\n                this[type] = res\n              }),\n            )\n          } else {\n            this[type] = this.route[type]\n          }\n        })\n\n        const loader = this.route.loader\n\n        const dataPromise = !loader\n          ? Promise.resolve().then(() => {\n              this.status = 'resolved'\n            })\n          : new Promise(async (resolveLoader, rejectLoader) => {\n              let pendingTimeout: Timeout\n\n              const resolve = (data: any) => {\n                this.status = 'resolved'\n                this.data = data\n                this.error = undefined\n              }\n\n              const reject = (err: any) => {\n                console.error(err)\n                this.status = 'rejected'\n                this.error = err\n                rejectLoader(err)\n              }\n\n              const finish = () => {\n                this.isLoading = false\n                this.startPending = undefined\n                clearTimeout(pendingTimeout)\n                resolveLoader(this.data)\n              }\n\n              try {\n                this.isLoading = true\n\n                resolve(\n                  await loader(this, {\n                    parentMatch: opts.parentMatch,\n                    dispatch: async (event) => {\n                      if (event.type === 'resolve') {\n                        resolve(event.data)\n                      } else if (event.type === 'reject') {\n                        reject(event.error)\n                      } else if (event.type === 'loading') {\n                        this.isLoading = true\n                      } else if (event.type === 'maxAge') {\n                        this.maxAge = event.maxAge\n                      }\n\n                      this.updatedAt = Date.now()\n\n                      this.notify?.(true)\n                    },\n                  }),\n                )\n                await this.pendingMinPromise\n                finish()\n              } catch (err) {\n                reject(err)\n                finish()\n              }\n            })\n\n        return Promise.all([...elementPromises, dataPromise]).then(() => {\n          this.updatedAt = Date.now()\n        })\n      })\n      .then(() => {\n        return this.data\n      })\n  }\n}\n\nclass MatchLoader<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> extends Subscribable<undefined | boolean> {\n  router: RouterInstance<TGenerics>\n  location: Location<TGenerics>\n  matches: RouteMatch<TGenerics>[]\n  prepPromise?: Promise<void>\n  matchPromise?: Promise<UnloadedMatch<TGenerics>[]>\n  firstRenderPromises?: Promise<any>[]\n\n  constructor(\n    router: RouterInstance<TGenerics>,\n    nextLocation: Location<TGenerics>,\n  ) {\n    super()\n    this.router = router\n    this.location = nextLocation\n    this.matches = []\n\n    this.loadMatches()\n  }\n\n  status: 'pending' | 'resolved' = 'pending'\n\n  preNotify = (isSoft?: boolean) => {\n    if (this.status === 'pending' && isSoft) {\n      return\n    }\n\n    this.status = 'resolved'\n\n    this.matches?.forEach((match, index) => {\n      const parentMatch = this.matches?.[index - 1]\n\n      match.data = {\n        ...(parentMatch?.data ?? ({} as any)),\n        ...match.data,\n      }\n    })\n\n    this.notify(false)\n  }\n\n  private loadMatches = () => {\n    const unloadedMatches = matchRoutes(this.router, this.location)\n\n    this.matches = unloadedMatches?.map(\n      (unloadedMatch): RouteMatch<TGenerics> => {\n        if (!this.router.matchCache[unloadedMatch.id]) {\n          this.router.matchCache[unloadedMatch.id] = new RouteMatch(\n            unloadedMatch,\n          )\n        }\n\n        return this.router.matchCache[unloadedMatch.id]!\n      },\n    )\n  }\n\n  loadData = async ({ maxAge }: { maxAge?: number } = {}) => {\n    this.loadMatches()\n    this.router.cleanMatchCache()\n\n    if (!this.matches?.length) {\n      this.preNotify()\n      return\n    }\n\n    this.firstRenderPromises = []\n\n    this.matches.forEach((match, index) => {\n      const parentMatch = this.matches?.[index - 1]\n      match.assignMatchLoader?.(this)\n      match.load?.({ maxAge, parentMatch, router: this.router })\n      this.firstRenderPromises?.push(match.loaderPromise!)\n    })\n\n    return await Promise.all(this.firstRenderPromises).then(() => {\n      this.preNotify()\n      return this.matches\n    })\n  }\n\n  load = async ({ maxAge }: { maxAge?: number } = {}) => {\n    this.loadMatches()\n    return await this.loadData({ maxAge })\n  }\n\n  startPending = async () => {\n    this.matches.forEach((match) => match.startPending?.())\n  }\n}\n\nexport type UseRouterType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => RouterInstance<TGenerics>\n\nexport function useRouter<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouterInstance<TGenerics> {\n  const value = React.useContext(routerContext)\n  if (!value) {\n    warning(true, 'You are trying to use useRouter() outside of ReactLocation!')\n    throw new Error()\n  }\n\n  return value.router as RouterInstance<TGenerics>\n}\n\nexport interface MatchRoutesOptions<TGenerics> {\n  filterRoutes?: FilterRoutesFn\n  defaultPendingMs?: number\n  defaultPendingMinMs?: number\n  defaultElement?: SyncOrAsyncElement<TGenerics>\n  defaultErrorElement?: SyncOrAsyncElement<TGenerics>\n  defaultPendingElement?: SyncOrAsyncElement<TGenerics>\n}\n\nexport type MatchRoutesType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (\n  router: RouterInstance<TGenerics>[],\n  currentLocation: Location<TGenerics>,\n) => Promise<UnloadedMatch<TGenerics>[]>\n\nexport function matchRoutes<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  router: RouterInstance<TGenerics>,\n  currentLocation: Location<TGenerics>,\n): UnloadedMatch<TGenerics>[] {\n  if (!router.routes?.length) {\n    return []\n  }\n\n  const matches: UnloadedMatch<TGenerics>[] = []\n\n  const recurse = async (\n    routes: Route<TGenerics>[],\n    parentMatch: UnloadedMatch<TGenerics>,\n  ): Promise<void> => {\n    let { pathname, params } = parentMatch\n    const filteredRoutes = router?.filterRoutes\n      ? router?.filterRoutes(routes)\n      : routes\n\n    let routeIndex: number = -1\n\n    const originalRoute = filteredRoutes.find((route, index) => {\n      const fullRoutePathName = joinPaths([pathname, route.path])\n\n      const fuzzy = !!(route.path !== '/' || route.children?.length)\n\n      const matchParams = matchRoute(currentLocation, {\n        to: fullRoutePathName,\n        search: route.search,\n        fuzzy,\n      })\n\n      if (matchParams) {\n        routeIndex = index\n        params = {\n          ...params,\n          ...matchParams,\n        }\n      }\n\n      return !!matchParams\n    })\n\n    if (!originalRoute) {\n      return\n    }\n\n    const interpolatedPathSegments = parsePathname(originalRoute.path)\n\n    const interpolatedPath = joinPaths(\n      interpolatedPathSegments.map((segment) => {\n        if (segment.value === '*') {\n          return ''\n        }\n\n        if (segment.type === 'param') {\n          return params![segment.value.substring(1)] ?? ''\n        }\n\n        return segment.value\n      }),\n    )\n\n    pathname = joinPaths([pathname, interpolatedPath])\n\n    const id = joinPaths([\n      parentMatch.id === 'root' ? '' : parentMatch.id,\n      `${interpolatedPath}-${routeIndex.toString()}`,\n    ])\n\n    const match: UnloadedMatch<TGenerics> = {\n      id,\n      route: {\n        ...originalRoute,\n        pendingMs: originalRoute.pendingMs ?? router?.defaultPendingMs,\n        pendingMinMs: originalRoute.pendingMinMs ?? router?.defaultPendingMinMs,\n      },\n      routeIndex,\n      params,\n      pathname,\n      search: currentLocation.search,\n    }\n\n    matches.push(match)\n\n    if (originalRoute.children?.length) {\n      recurse(originalRoute.children, match)\n    }\n  }\n\n  recurse(router.routes, router.rootMatch)\n\n  return matches\n}\n\nexport type UseLoadRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (routes?: Route<TGenerics>[]) => void\n\nexport function useLoadRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const router = useRouter<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  return useLatestCallback(\n    async (\n      navigate: NavigateOptions<TGenerics> = location.current,\n      opts?: { maxAge?: number },\n    ) => {\n      const next = buildNext({\n        ...navigate,\n        from: navigate.from ?? { pathname: match.pathname },\n      })\n\n      const matchLoader = router.getMatchLoader(next)\n\n      return await matchLoader.load(opts)\n    },\n  )\n}\n\nexport type UseMatchesType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => RouteMatch<TGenerics>[]\n\nexport function useParentMatches<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics>[] {\n  const router = useRouter<TGenerics>()\n  const match = useMatch()\n\n  const matches = router.state.matches\n\n  return matches.slice(0, matches.findIndex((d) => d.id === match.id) - 1)\n}\n\nexport function useMatches<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics>[] {\n  return React.useContext(MatchesContext)\n}\n\nexport type UseMatchType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => RouteMatch<TGenerics>\n\nexport function useMatch<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): RouteMatch<TGenerics> {\n  return useMatches<TGenerics>()?.[0]!\n}\n\nexport type UseNavigateType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (options: NavigateOptions<TGenerics>) => void\n\nexport function useNavigate<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  function navigate({\n    search,\n    hash,\n    replace,\n    from,\n    to,\n    fromCurrent,\n  }: NavigateOptions<TGenerics> & {\n    replace?: boolean\n  }) {\n    fromCurrent = fromCurrent ?? typeof to === 'undefined'\n\n    const next = buildNext({\n      to,\n      search,\n      hash,\n      from: fromCurrent\n        ? location.current\n        : from ?? { pathname: match.pathname },\n    })\n\n    location.navigate(next, replace)\n  }\n\n  return useLatestCallback(navigate)\n}\n\nexport type NavigateType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  (options: NavigateOptions<TGenerics>) => null\n\nexport function Navigate<TGenerics extends PartialGenerics = DefaultGenerics>(\n  options: NavigateOptions<TGenerics>,\n) {\n  let navigate = useNavigate<TGenerics>()\n\n  useLayoutEffect(() => {\n    navigate(options)\n  }, [navigate])\n\n  return null\n}\n\nfunction useBuildNext<TGenerics>() {\n  const location = useLocation<TGenerics>()\n  const router = useRouter<TGenerics>()\n\n  const buildNext = (opts: BuildNextOptions<TGenerics>) => {\n    const next = location.buildNext(router.basepath, opts)\n\n    const matches = matchRoutes<TGenerics>(router, next)\n\n    const __searchFilters = matches\n      .map((match) => match.route.searchFilters ?? [])\n      .flat()\n      .filter(Boolean)\n\n    return location.buildNext(router.basepath, { ...opts, __searchFilters })\n  }\n\n  return useLatestCallback(buildNext)\n}\n\nexport type LinkType<TGenerics extends PartialGenerics = DefaultGenerics> = (\n  props: LinkProps<TGenerics>,\n) => JSX.Element\n\nexport const Link = function Link<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>({\n  to = '.',\n  search,\n  hash,\n  children,\n  target,\n  style = {},\n  replace,\n  onClick,\n  onMouseEnter,\n  className = '',\n  getActiveProps = () => ({}),\n  activeOptions,\n  preload,\n  disabled,\n  _ref,\n  ...rest\n}: LinkProps<TGenerics>) {\n  const loadRoute = useLoadRoute<TGenerics>()\n  const match = useMatch<TGenerics>()\n  const location = useLocation<TGenerics>()\n  const router = useRouter<TGenerics>()\n  const navigate = useNavigate<TGenerics>()\n  const buildNext = useBuildNext<TGenerics>()\n\n  preload = preload ?? router.defaultLinkPreloadMaxAge\n\n  // If this `to` is a valid external URL, log a warning\n  try {\n    const url = new URL(`${to}`)\n    warning(\n      false,\n      `<Link /> should not be used for external URLs like: ${url.href}`,\n    )\n  } catch (e) {}\n\n  const next = buildNext({\n    to,\n    search,\n    hash,\n    from: { pathname: match.pathname },\n  })\n\n  // The click handler\n  const handleClick = (e: React.MouseEvent<HTMLAnchorElement>) => {\n    if (onClick) onClick(e)\n\n    if (\n      !isCtrlEvent(e) &&\n      !e.defaultPrevented &&\n      (!target || target === '_self') &&\n      e.button === 0\n    ) {\n      e.preventDefault()\n      // All is well? Navigate!\n      navigate({\n        to,\n        search,\n        hash,\n        replace,\n        from: { pathname: match.pathname },\n      })\n    }\n  }\n\n  // The click handler\n  const handleMouseEnter = (e: React.MouseEvent<HTMLAnchorElement>) => {\n    if (onMouseEnter) onMouseEnter(e)\n\n    if (preload && preload > 0) {\n      loadRoute(\n        {\n          to,\n          search,\n          hash,\n        },\n        { maxAge: preload },\n      )\n    }\n  }\n\n  // Compare path/hash for matches\n  const pathIsEqual = location.current.pathname === next.pathname\n  const currentPathSplit = location.current.pathname.split('/')\n  const nextPathSplit = next.pathname.split('/')\n  const pathIsFuzzyEqual = nextPathSplit.every(\n    (d, i) => d === currentPathSplit[i],\n  )\n  const hashIsEqual = location.current.hash === next.hash\n\n  // Combine the matches based on user options\n  const pathTest = activeOptions?.exact ? pathIsEqual : pathIsFuzzyEqual\n  const hashTest = activeOptions?.includeHash ? hashIsEqual : true\n\n  // The final \"active\" test\n  const isActive = pathTest && hashTest\n\n  // Get the active props\n  const {\n    style: activeStyle = {},\n    className: activeClassName = '',\n    ...activeRest\n  } = isActive ? getActiveProps() : {}\n\n  return (\n    <a\n      {...{\n        ref: _ref,\n        href: disabled ? undefined : next.href,\n        onClick: handleClick,\n        onMouseEnter: handleMouseEnter,\n        target,\n        style: {\n          ...style,\n          ...activeStyle,\n        },\n        className:\n          [className, activeClassName].filter(Boolean).join(' ') || undefined,\n        ...(disabled\n          ? {\n              role: 'link',\n              'aria-disabled': true,\n            }\n          : undefined),\n        ...rest,\n        ...activeRest,\n        children:\n          typeof children === 'function' ? children({ isActive }) : children,\n      }}\n    />\n  )\n}\n\nexport function Outlet<TGenerics extends PartialGenerics = DefaultGenerics>() {\n  const router = useRouter<TGenerics>()\n  const [_, ...matches] = useMatches<TGenerics>()\n\n  const match = matches[0]\n\n  if (!match) {\n    return null\n  }\n\n  const errorElement = match.errorElement ?? router.defaultErrorElement\n\n  const element = (() => {\n    if (match.status === 'rejected') {\n      if (errorElement) {\n        return errorElement\n      }\n\n      if (!router.useErrorBoundary) {\n        if (process.env.NODE_ENV !== 'production') {\n          const preStyle: React.HTMLAttributes<HTMLPreElement>['style'] = {\n            whiteSpace: 'normal',\n            display: 'inline-block',\n            background: 'rgba(0,0,0,.1)',\n            padding: '.1rem .2rem',\n            margin: '.1rem',\n            lineHeight: '1',\n            borderRadius: '.25rem',\n          }\n\n          return (\n            <div style={{ lineHeight: '1.7' }}>\n              <strong>\n                The following error occured in the loader for you route at:{' '}\n                <pre style={preStyle}>{match.pathname}</pre>\n              </strong>\n              .\n              <br />\n              <pre\n                style={{\n                  ...preStyle,\n                  display: 'block',\n                  padding: '.5rem',\n                  borderRadius: '.5rem',\n                }}\n              >\n                {(match.error as any).toString()}\n              </pre>\n              <br />\n              Your users won't see this message in production, but they will see{' '}\n              <strong>\"An unknown error occured!\"</strong>, which is at least\n              better than breaking your entire app. ðŸ˜Š For a better UX, please\n              specify an <pre style={preStyle}>errorElement</pre> for all of\n              your routes that contain asynchronous behavior, or at least\n              provide your own\n              <pre style={preStyle}>ErrorBoundary</pre> wrapper around your\n              renders to both the elements rendered by{' '}\n              <pre style={preStyle}>\n                {'useRoutes(routes, { useErrorBoundary: true })'}\n              </pre>{' '}\n              and <pre style={preStyle}>{'<Router useErrorBoundary />'}</pre>.{' '}\n              <br />\n              <br />\n            </div>\n          )\n        }\n        return 'An unknown error occured!'\n      }\n\n      throw match.error\n    }\n\n    const pendingElement = match.pendingElement ?? router.defaultPendingElement\n\n    if (match.status === 'pending') {\n      if (match.route.pendingMs || pendingElement) {\n        return pendingElement ?? null\n      }\n    }\n\n    const matchElement = match.element ?? router.defaultElement\n\n    return matchElement ? (\n      <React.Fragment>{matchElement}</React.Fragment>\n    ) : (\n      <Outlet<TGenerics> />\n    )\n  })()\n\n  return <MatchesProvider value={matches}>{element}</MatchesProvider>\n}\n\nexport function useResolvePath<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const router = useRouter<TGenerics>()\n  const match = useMatch<TGenerics>()\n\n  return useLatestCallback((path: string) =>\n    resolvePath(router.basepath!, match.pathname!, cleanPath(path)),\n  )\n}\n\nexport type UseSearchType<TGenerics extends PartialGenerics = DefaultGenerics> =\n  () => Partial<Maybe<TGenerics['Search'], Search<any>>>\n\nexport function useSearch<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>() {\n  const location = useLocation<TGenerics>()\n  return location.current.search\n}\n\nexport type MatchRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = (\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n) => UseGeneric<TGenerics, 'Params'> | undefined\n\nexport function matchRoute<TGenerics extends PartialGenerics = DefaultGenerics>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n): UseGeneric<TGenerics, 'Params'> | undefined {\n  const pathParams = matchByPath(currentLocation, matchLocation)\n  const searchMatched = matchBySearch(currentLocation, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  if (matchLocation.search && !searchMatched) {\n    return\n  }\n\n  return (pathParams ?? {}) as UseGeneric<TGenerics, 'Params'>\n}\n\nexport type UseMatchRouteType<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n> = () => (\n  matchLocation: MatchLocation<TGenerics>,\n) => Maybe<TGenerics['Params'], Params<any>> | undefined\n\nexport type UseMatchRouteOptions<TGenerics> = MatchLocation<TGenerics> & {\n  pending?: boolean\n}\n\nexport function useMatchRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(): (\n  matchLocation: UseMatchRouteOptions<TGenerics>,\n) => Maybe<TGenerics['Params'], Params<any>> | undefined {\n  const router = useRouter<TGenerics>()\n  const resolvePath = useResolvePath<TGenerics>()\n\n  return useLatestCallback(\n    ({\n      pending,\n      ...matchLocation\n    }: MatchLocation<TGenerics> & { pending?: boolean }) => {\n      matchLocation = {\n        ...matchLocation,\n        to: matchLocation.to ? resolvePath(`${matchLocation.to}`) : undefined,\n      }\n\n      if (pending) {\n        if (!router.pending?.location) {\n          return undefined\n        }\n        return matchRoute(router.pending.location, matchLocation)\n      }\n\n      return matchRoute(router.state.location, matchLocation)\n    },\n  )\n}\n\nexport function MatchRoute<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>({\n  children,\n  ...rest\n}: UseMatchRouteOptions<TGenerics> & {\n  children:\n    | React.ReactNode\n    | ((isNextLocation?: Params<TGenerics>) => React.ReactNode)\n}) {\n  const matchRoute = useMatchRoute<TGenerics>()\n  const match = matchRoute(rest)\n\n  if (typeof children === 'function') {\n    return children(match as any)\n  }\n\n  return match ? children : null\n}\n\nexport function usePrompt(message: string, when: boolean | any): void {\n  const location = useLocation()\n\n  React.useEffect(() => {\n    if (!when) return\n\n    let unblock = location.history.block((transition) => {\n      if (window.confirm(message)) {\n        unblock()\n        transition.retry()\n      } else {\n        location.current.pathname = window.location.pathname\n      }\n    })\n\n    return unblock\n  }, [when, location, message])\n}\n\nexport function Prompt({ message, when, children }: PromptProps) {\n  usePrompt(message, when ?? true)\n  return children ?? null\n}\n\nfunction warning(cond: boolean, message: string) {\n  if (!cond) {\n    if (typeof console !== 'undefined') console.warn(message)\n\n    try {\n      throw new Error(message)\n    } catch {}\n  }\n}\n\nfunction isFunction(d: any): d is Function {\n  return typeof d === 'function'\n}\n\nexport function functionalUpdate<TResult>(\n  updater?: Updater<TResult>,\n  previous?: TResult,\n) {\n  if (isFunction(updater)) {\n    return updater(previous as TResult)\n  }\n\n  return updater\n}\n\nfunction joinPaths(paths: (string | undefined)[]) {\n  return cleanPath(paths.filter(Boolean).join('/'))\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return `${path}`.replace(/\\/{2,}/g, '/')\n}\n\nexport function matchByPath<\n  TGenerics extends PartialGenerics = DefaultGenerics,\n>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n): UseGeneric<TGenerics, 'Params'> | undefined {\n  const baseSegments = parsePathname(currentLocation.pathname)\n  const routeSegments = parsePathname(`${matchLocation.to ?? '*'}`)\n\n  // console.log(baseSegments, routeSegments)\n\n  const params: Record<string, string> = {}\n\n  let isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastRouteSegment = i === routeSegments.length - 1\n      const isLastBaseSegment = i === baseSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          if (baseSegment?.value) {\n            params['*'] = joinPaths(baseSegments.slice(i).map((d) => d.value))\n            return true\n          }\n          return false\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (routeSegment.value !== baseSegment.value) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          params[routeSegment.value.substring(1)] = baseSegment.value\n        }\n      }\n\n      if (isLastRouteSegment && !isLastBaseSegment) {\n        return !!matchLocation.fuzzy\n      }\n    }\n    return true\n  })()\n\n  return isMatch ? (params as UseGeneric<TGenerics, 'Params'>) : undefined\n}\n\nfunction matchBySearch<TGenerics extends PartialGenerics = DefaultGenerics>(\n  currentLocation: Location<TGenerics>,\n  matchLocation: MatchLocation<TGenerics>,\n) {\n  return !!(\n    matchLocation.search && matchLocation.search(currentLocation.search)\n  )\n}\n\nexport function parsePathname(pathname?: string): Segment[] {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Segment[] = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part.startsWith('*')) {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === ':') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part,\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\nfunction resolvePath(basepath: string, base: string, to: string) {\n  base = base.replace(new RegExp(`^${basepath}`), '/')\n  to = to.replace(new RegExp(`^${basepath}`), '/')\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        baseSegments = [toSegment]\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      return\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n\n  return cleanPath(joined)\n}\n\nfunction isCtrlEvent(e: React.MouseEvent) {\n  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n}\n\nfunction useLatestCallback<TCallback extends (...args: any[]) => any>(\n  cb: TCallback,\n) {\n  const stableFnRef =\n    React.useRef<(...args: Parameters<TCallback>) => ReturnType<TCallback>>()\n  const cbRef = React.useRef<TCallback>(cb)\n\n  cbRef.current = cb\n\n  if (!stableFnRef.current) {\n    stableFnRef.current = (...args) => cbRef.current(...args)\n  }\n\n  return stableFnRef.current\n}\n\nfunction useGetIsMounted() {\n  const ref = React.useRef(false)\n\n  React.useEffect(() => {\n    ref.current = true\n\n    return () => {\n      ref.current = false\n    }\n  })\n\n  return () => ref.current\n}\n\n/**\n * This function returns `a` if `b` is deeply equal.\n * If not, it will replace any deeply equal children of `b` with those of `a`.\n * This can be used for structural sharing between JSON values for example.\n */\nfunction replaceEqualDeep(prev: any, next: any) {\n  if (prev === next) {\n    return prev\n  }\n\n  const array = Array.isArray(prev) && Array.isArray(next)\n\n  if (array || (isPlainObject(prev) && isPlainObject(next))) {\n    const aSize = array ? prev.length : Object.keys(prev).length\n    const bItems = array ? next : Object.keys(next)\n    const bSize = bItems.length\n    const copy: any = array ? [] : {}\n\n    let equalItems = 0\n\n    for (let i = 0; i < bSize; i++) {\n      const key = array ? i : bItems[i]\n      copy[key] = replaceEqualDeep(prev[key], next[key])\n      if (copy[key] === prev[key]) {\n        equalItems++\n      }\n    }\n\n    return aSize === bSize && equalItems === aSize ? prev : copy\n  }\n\n  return next\n}\n\n// Copied from: https://github.com/jonschlinkert/is-plain-object\nfunction isPlainObject(o: any) {\n  if (!hasObjectPrototype(o)) {\n    return false\n  }\n\n  // If has modified constructor\n  const ctor = o.constructor\n  if (typeof ctor === 'undefined') {\n    return true\n  }\n\n  // If has modified prototype\n  const prot = ctor.prototype\n  if (!hasObjectPrototype(prot)) {\n    return false\n  }\n\n  // If constructor does not have an Object-specific method\n  if (!prot.hasOwnProperty('isPrototypeOf')) {\n    return false\n  }\n\n  // Most likely a plain Object\n  return true\n}\n\nfunction hasObjectPrototype(o: any) {\n  return Object.prototype.toString.call(o) === '[object Object]'\n}\n\nexport function defaultStringifySearch(search: Record<string, unknown>) {\n  search = { ...search }\n\n  if (search) {\n    Object.keys(search).forEach((key) => {\n      const val = search[key]\n      if (typeof val === 'undefined' || val === undefined) {\n        delete search[key]\n      } else if (val && typeof val === 'object' && val !== null) {\n        try {\n          search[key] = JSON.stringify(val)\n        } catch (err) {\n          // silent\n        }\n      }\n    })\n  }\n\n  const searchStr = new URLSearchParams(\n    search as Record<string, string>,\n  ).toString()\n\n  return searchStr ? `?${searchStr}` : ''\n}\n\nexport function defaultParseSearch(searchStr: string): Record<string, any> {\n  if (searchStr.substring(0, 1) === '?') {\n    searchStr = searchStr.substring(1)\n  }\n\n  let query: Record<string, unknown> = Object.fromEntries(\n    (new URLSearchParams(searchStr) as any).entries(),\n  )\n\n  // Try to parse query params\n  for (let key in query) {\n    const value = query[key]\n\n    try {\n      query[key] = JSON.parse(value as string)\n    } catch (err) {\n      //\n    }\n  }\n\n  return query\n}\n"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","this","LocationContext","React","createContext","MatchesContext","routerContext","isDOM","Boolean","window","document","createElement","useLayoutEffect","useEffect","Subscribable","listeners","subscribe","listener","push","_this","filter","x","notify","payload","forEach","ReactLocation","options","isTransitioning","history","createBrowserHistory","createMemoryHistory","stringifySearch","defaultStringifySearch","parseSearch","defaultParseSearch","current","_this2","parseLocation","location","destroy","listen","event","buildNext","basepath","dest","from","pathname","resolvePath","to","updatedSearch","search","functionalUpdate","filteredSearch","__searchFilters","reduce","prev","next","replaceEqualDeep","searchStr","hash","href","navigate","replace","navigateTimeout","clearTimeout","nextAction","setTimeout","_this3","previousLocation","parsedSearch","split","reverse","MatchesProvider","props","Provider","RouterInstance","opts","setState","updater","newState","state","_this4","pending","cleanMatchCache","matchCache","getMatchLoader","MatchLoader","activeMatchIds","_assertThisInitialize2","matches","_assertThisInitialize4","_assertThisInitialize5","map","d","id","values","match","updatedAt","includes","age","Date","now","maxAge","updateLocation","unsubscribe","promise","Promise","resolve","matchLoader","used","old","status","currentMatches","find","dd","onExit","route","onTransition","onMatch","undefined","loadData","startPending","cleanPath","rootMatch","params","routeIndex","data","isLoading","initialMatches","useLocation","ref","getIsMounted","useRef","rerender","useReducer","instance","useContext","then","RouteMatch","unloadedMatch","isSoft","_this5","assignMatchLoader","pendingTimeout","pendingMs","pendingMinMs","pendingMinPromise","r","load","loaderMaxAge","router","defaultLoaderMaxAge","loaderPromise","importer","import","imported","elementPromises","type","routeElement","res","loader","dataPromise","resolveLoader","rejectLoader","reject","finish","error","err","console","$Try_1_Post","$error","$Try_1_Catch","parentMatch","dispatch","$await_6","all","nextLocation","preNotify","_this6","index","_this6$matches2","loadMatches","unloadedMatches","matchRoutes","_this6$matches3","firstRenderPromises","_this6$matches4","useRouter","value","Error","currentLocation","routes","_router$routes","recurse","filteredRoutes","filterRoutes","originalRoute","fullRoutePathName","joinPaths","path","fuzzy","children","_route$children","matchParams","matchRoute","interpolatedPath","parsePathname","segment","substring","toString","defaultPendingMs","defaultPendingMinMs","_originalRoute$childr","useLoadRoute","useMatch","useBuildNext","useLatestCallback","useMatches","_useMatches","useNavigate","fromCurrent","searchFilters","flat","useResolvePath","matchLocation","pathParams","matchByPath","searchMatched","matchBySearch","useMatchRoute","_router$pending","usePrompt","message","when","unblock","block","transition","confirm","retry","previous","paths","join","baseSegments","routeSegments","Math","max","baseSegment","routeSegment","isLastRouteSegment","isLastBaseSegment","slice","segments","part","startsWith","charAt","base","RegExp","toSegment","pop","cb","stableFnRef","cbRef","array","Array","isArray","isPlainObject","aSize","keys","bItems","bSize","copy","equalItems","o","hasObjectPrototype","ctor","constructor","prot","val","JSON","stringify","URLSearchParams","query","fromEntries","entries","parse","style","onClick","onMouseEnter","className","getActiveProps","activeOptions","preload","disabled","_ref","rest","loadRoute","defaultLinkPreloadMaxAge","URL","e","pathIsEqual","currentPathSplit","pathIsFuzzyEqual","every","hashIsEqual","pathTest","exact","hashTest","includeHash","isActive","activeStyle","activeClassName","activeRest","metaKey","altKey","ctrlKey","shiftKey","isCtrlEvent","defaultPrevented","button","preventDefault","role","Outlet","errorElement","defaultErrorElement","element","useErrorBoundary","pendingElement","defaultPendingElement","matchElement","defaultElement","Fragment","routerRef","nonce","routerValue","useMemo","findIndex"],"mappings":"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"}